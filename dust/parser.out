Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_items
Rule 2     program_items -> program_items program_item
Rule 3     program_items -> program_item
Rule 4     program_item -> import_stmt
Rule 5     program_item -> function_decl
Rule 6     program_item -> struct_decl
Rule 7     program_item -> statement
Rule 8     statement -> variable_decl
Rule 9     statement -> assignment
Rule 10    statement -> if_stmt
Rule 11    statement -> while_stmt
Rule 12    statement -> for_stmt
Rule 13    statement -> return_stmt
Rule 14    statement -> expr_stmt
Rule 15    statement -> block
Rule 16    import_stmt -> IMPORT STRING SEMICOLON
Rule 17    function_decl -> FN ID LPAREN parameters_opt RPAREN block
Rule 18    parameters_opt -> parameters
Rule 19    parameters_opt -> empty
Rule 20    parameters -> ID
Rule 21    parameters -> parameters COMMA ID
Rule 22    struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON
Rule 23    struct_fields -> ID COMMA struct_fields
Rule 24    struct_fields -> ID COMMA
Rule 25    struct_fields -> empty
Rule 26    variable_decl -> LET ID ASSIGN expr SEMICOLON
Rule 27    assignment -> assign_target ASSIGN expr SEMICOLON
Rule 28    assign_target -> ID
Rule 29    assign_target -> assign_target DOT ID
Rule 30    assign_target -> assign_target LBRACKET expr RBRACKET
Rule 31    if_stmt -> IF expr block elif_blocks else_block_opt
Rule 32    elif_blocks -> elif_blocks ELIF expr block
Rule 33    elif_blocks -> empty
Rule 34    else_block_opt -> ELSE block
Rule 35    else_block_opt -> empty
Rule 36    while_stmt -> WHILE expr block
Rule 37    for_stmt -> FOR ID IN expr block
Rule 38    return_stmt -> RETURN expr SEMICOLON
Rule 39    return_stmt -> RETURN SEMICOLON
Rule 40    expr_stmt -> expr SEMICOLON
Rule 41    block -> LBRACE statement_list RBRACE
Rule 42    statement_list -> statement_list statement
Rule 43    statement_list -> empty
Rule 44    primary_expr -> ID
Rule 45    primary_expr -> literal
Rule 46    primary_expr -> LPAREN expr RPAREN
Rule 47    primary_expr -> struct_literal
Rule 48    primary_expr -> array_literal
Rule 49    postfix_expr -> primary_expr postfix_chain
Rule 50    postfix_chain -> postfix postfix_chain
Rule 51    postfix_chain -> empty
Rule 52    postfix -> LPAREN args_opt RPAREN
Rule 53    postfix -> DOT ID
Rule 54    postfix -> LBRACKET expr RBRACKET
Rule 55    unary_expr -> NOT unary_expr
Rule 56    unary_expr -> MINUS unary_expr
Rule 57    unary_expr -> postfix_expr
Rule 58    exponential_expr -> unary_expr
Rule 59    exponential_expr -> unary_expr POWER exponential_expr
Rule 60    multiplicative_expr -> exponential_expr
Rule 61    multiplicative_expr -> multiplicative_expr TIMES exponential_expr
Rule 62    multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr
Rule 63    multiplicative_expr -> multiplicative_expr MOD exponential_expr
Rule 64    additive_expr -> multiplicative_expr
Rule 65    additive_expr -> additive_expr PLUS multiplicative_expr
Rule 66    additive_expr -> additive_expr MINUS multiplicative_expr
Rule 67    relational_expr -> additive_expr
Rule 68    relational_expr -> relational_expr LT additive_expr
Rule 69    relational_expr -> relational_expr GT additive_expr
Rule 70    relational_expr -> relational_expr LE additive_expr
Rule 71    relational_expr -> relational_expr GE additive_expr
Rule 72    equality_expr -> relational_expr
Rule 73    equality_expr -> equality_expr EQ relational_expr
Rule 74    equality_expr -> equality_expr NE relational_expr
Rule 75    logical_and_expr -> equality_expr
Rule 76    logical_and_expr -> logical_and_expr AND equality_expr
Rule 77    logical_or_expr -> logical_and_expr
Rule 78    logical_or_expr -> logical_or_expr OR logical_and_expr
Rule 79    expr -> logical_or_expr
Rule 80    literal -> INTEGER
Rule 81    literal -> FLOAT
Rule 82    literal -> STRING
Rule 83    literal -> TRUE
Rule 84    literal -> FALSE
Rule 85    literal -> NULL
Rule 86    args_opt -> args
Rule 87    args_opt -> empty
Rule 88    args -> expr
Rule 89    args -> args COMMA expr
Rule 90    struct_literal -> ID LBRACE field_assignments_opt RBRACE
Rule 91    field_assignments_opt -> field_assignments
Rule 92    field_assignments_opt -> empty
Rule 93    field_assignments -> field_assign
Rule 94    field_assignments -> field_assignments COMMA field_assign
Rule 95    field_assign -> ID COLON expr
Rule 96    array_literal -> LBRACKET expr_list_opt RBRACKET
Rule 97    expr_list_opt -> expr_list
Rule 98    expr_list_opt -> empty
Rule 99    expr_list -> expr
Rule 100   expr_list -> expr_list COMMA expr
Rule 101   empty -> <empty>

Terminals, with rules where they appear

AND                  : 76
ASSIGN               : 26 27
COLON                : 95
COMMA                : 21 23 24 89 94 100
DIVIDE               : 62
DOT                  : 29 53
ELIF                 : 32
ELSE                 : 34
EQ                   : 73
FALSE                : 84
FLOAT                : 81
FN                   : 17
FOR                  : 37
GE                   : 71
GT                   : 69
ID                   : 17 20 21 22 23 24 26 28 29 37 44 53 90 95
IF                   : 31
IMPORT               : 16
IN                   : 37
INTEGER              : 80
LBRACE               : 22 41 90
LBRACKET             : 30 54 96
LE                   : 70
LET                  : 26
LPAREN               : 17 46 52
LT                   : 68
MINUS                : 56 66
MOD                  : 63
NE                   : 74
NOT                  : 55
NULL                 : 85
OR                   : 78
PLUS                 : 65
POWER                : 59
RBRACE               : 22 41 90
RBRACKET             : 30 54 96
RETURN               : 38 39
RPAREN               : 17 46 52
SEMICOLON            : 16 22 26 27 38 39 40
STRING               : 16 82
STRUCT               : 22
TIMES                : 61
TRUE                 : 83
WHILE                : 36
error                : 

Nonterminals, with rules where they appear

additive_expr        : 65 66 67 68 69 70 71
args                 : 86 89
args_opt             : 52
array_literal        : 48
assign_target        : 27 29 30
assignment           : 9
block                : 15 17 31 32 34 36 37
elif_blocks          : 31 32
else_block_opt       : 31
empty                : 19 25 33 35 43 51 87 92 98
equality_expr        : 73 74 75 76
exponential_expr     : 59 60 61 62 63
expr                 : 26 27 30 31 32 36 37 38 40 46 54 88 89 95 99 100
expr_list            : 97 100
expr_list_opt        : 96
expr_stmt            : 14
field_assign         : 93 94
field_assignments    : 91 94
field_assignments_opt : 90
for_stmt             : 12
function_decl        : 5
if_stmt              : 10
import_stmt          : 4
literal              : 45
logical_and_expr     : 76 77 78
logical_or_expr      : 78 79
multiplicative_expr  : 61 62 63 64 65 66
parameters           : 18 21
parameters_opt       : 17
postfix              : 50
postfix_chain        : 49 50
postfix_expr         : 57
primary_expr         : 49
program              : 0
program_item         : 2 3
program_items        : 1 2
relational_expr      : 68 69 70 71 72 73 74
return_stmt          : 13
statement            : 7 42
statement_list       : 41 42
struct_decl          : 6
struct_fields        : 22 23
struct_literal       : 47
unary_expr           : 55 56 58 59
variable_decl        : 8
while_stmt           : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_items
    (2) program_items -> . program_items program_item
    (3) program_items -> . program_item
    (4) program_item -> . import_stmt
    (5) program_item -> . function_decl
    (6) program_item -> . struct_decl
    (7) program_item -> . statement
    (16) import_stmt -> . IMPORT STRING SEMICOLON
    (17) function_decl -> . FN ID LPAREN parameters_opt RPAREN block
    (22) struct_decl -> . STRUCT ID LBRACE struct_fields RBRACE SEMICOLON
    (8) statement -> . variable_decl
    (9) statement -> . assignment
    (10) statement -> . if_stmt
    (11) statement -> . while_stmt
    (12) statement -> . for_stmt
    (13) statement -> . return_stmt
    (14) statement -> . expr_stmt
    (15) statement -> . block
    (26) variable_decl -> . LET ID ASSIGN expr SEMICOLON
    (27) assignment -> . assign_target ASSIGN expr SEMICOLON
    (31) if_stmt -> . IF expr block elif_blocks else_block_opt
    (36) while_stmt -> . WHILE expr block
    (37) for_stmt -> . FOR ID IN expr block
    (38) return_stmt -> . RETURN expr SEMICOLON
    (39) return_stmt -> . RETURN SEMICOLON
    (40) expr_stmt -> . expr SEMICOLON
    (41) block -> . LBRACE statement_list RBRACE
    (28) assign_target -> . ID
    (29) assign_target -> . assign_target DOT ID
    (30) assign_target -> . assign_target LBRACKET expr RBRACKET
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    IMPORT          shift and go to state 8
    FN              shift and go to state 10
    STRUCT          shift and go to state 14
    LET             shift and go to state 23
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 29
    LBRACE          shift and go to state 15
    ID              shift and go to state 11
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    program                        shift and go to state 1
    program_items                  shift and go to state 2
    program_item                   shift and go to state 3
    import_stmt                    shift and go to state 4
    function_decl                  shift and go to state 5
    struct_decl                    shift and go to state 6
    statement                      shift and go to state 7
    block                          shift and go to state 13
    variable_decl                  shift and go to state 16
    assignment                     shift and go to state 17
    if_stmt                        shift and go to state 18
    while_stmt                     shift and go to state 19
    for_stmt                       shift and go to state 20
    return_stmt                    shift and go to state 21
    expr_stmt                      shift and go to state 22
    expr                           shift and go to state 24
    assign_target                  shift and go to state 25
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 1

    (0) S' -> program .



state 2

    (1) program -> program_items .
    (2) program_items -> program_items . program_item
    (4) program_item -> . import_stmt
    (5) program_item -> . function_decl
    (6) program_item -> . struct_decl
    (7) program_item -> . statement
    (16) import_stmt -> . IMPORT STRING SEMICOLON
    (17) function_decl -> . FN ID LPAREN parameters_opt RPAREN block
    (22) struct_decl -> . STRUCT ID LBRACE struct_fields RBRACE SEMICOLON
    (8) statement -> . variable_decl
    (9) statement -> . assignment
    (10) statement -> . if_stmt
    (11) statement -> . while_stmt
    (12) statement -> . for_stmt
    (13) statement -> . return_stmt
    (14) statement -> . expr_stmt
    (15) statement -> . block
    (26) variable_decl -> . LET ID ASSIGN expr SEMICOLON
    (27) assignment -> . assign_target ASSIGN expr SEMICOLON
    (31) if_stmt -> . IF expr block elif_blocks else_block_opt
    (36) while_stmt -> . WHILE expr block
    (37) for_stmt -> . FOR ID IN expr block
    (38) return_stmt -> . RETURN expr SEMICOLON
    (39) return_stmt -> . RETURN SEMICOLON
    (40) expr_stmt -> . expr SEMICOLON
    (41) block -> . LBRACE statement_list RBRACE
    (28) assign_target -> . ID
    (29) assign_target -> . assign_target DOT ID
    (30) assign_target -> . assign_target LBRACKET expr RBRACKET
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    $end            reduce using rule 1 (program -> program_items .)
    IMPORT          shift and go to state 8
    FN              shift and go to state 10
    STRUCT          shift and go to state 14
    LET             shift and go to state 23
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 29
    LBRACE          shift and go to state 15
    ID              shift and go to state 11
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    program_item                   shift and go to state 51
    import_stmt                    shift and go to state 4
    function_decl                  shift and go to state 5
    struct_decl                    shift and go to state 6
    statement                      shift and go to state 7
    block                          shift and go to state 13
    variable_decl                  shift and go to state 16
    assignment                     shift and go to state 17
    if_stmt                        shift and go to state 18
    while_stmt                     shift and go to state 19
    for_stmt                       shift and go to state 20
    return_stmt                    shift and go to state 21
    expr_stmt                      shift and go to state 22
    expr                           shift and go to state 24
    assign_target                  shift and go to state 25
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 3

    (3) program_items -> program_item .

    IMPORT          reduce using rule 3 (program_items -> program_item .)
    FN              reduce using rule 3 (program_items -> program_item .)
    STRUCT          reduce using rule 3 (program_items -> program_item .)
    LET             reduce using rule 3 (program_items -> program_item .)
    IF              reduce using rule 3 (program_items -> program_item .)
    WHILE           reduce using rule 3 (program_items -> program_item .)
    FOR             reduce using rule 3 (program_items -> program_item .)
    RETURN          reduce using rule 3 (program_items -> program_item .)
    LBRACE          reduce using rule 3 (program_items -> program_item .)
    ID              reduce using rule 3 (program_items -> program_item .)
    NOT             reduce using rule 3 (program_items -> program_item .)
    MINUS           reduce using rule 3 (program_items -> program_item .)
    LPAREN          reduce using rule 3 (program_items -> program_item .)
    INTEGER         reduce using rule 3 (program_items -> program_item .)
    FLOAT           reduce using rule 3 (program_items -> program_item .)
    STRING          reduce using rule 3 (program_items -> program_item .)
    TRUE            reduce using rule 3 (program_items -> program_item .)
    FALSE           reduce using rule 3 (program_items -> program_item .)
    NULL            reduce using rule 3 (program_items -> program_item .)
    LBRACKET        reduce using rule 3 (program_items -> program_item .)
    $end            reduce using rule 3 (program_items -> program_item .)


state 4

    (4) program_item -> import_stmt .

    IMPORT          reduce using rule 4 (program_item -> import_stmt .)
    FN              reduce using rule 4 (program_item -> import_stmt .)
    STRUCT          reduce using rule 4 (program_item -> import_stmt .)
    LET             reduce using rule 4 (program_item -> import_stmt .)
    IF              reduce using rule 4 (program_item -> import_stmt .)
    WHILE           reduce using rule 4 (program_item -> import_stmt .)
    FOR             reduce using rule 4 (program_item -> import_stmt .)
    RETURN          reduce using rule 4 (program_item -> import_stmt .)
    LBRACE          reduce using rule 4 (program_item -> import_stmt .)
    ID              reduce using rule 4 (program_item -> import_stmt .)
    NOT             reduce using rule 4 (program_item -> import_stmt .)
    MINUS           reduce using rule 4 (program_item -> import_stmt .)
    LPAREN          reduce using rule 4 (program_item -> import_stmt .)
    INTEGER         reduce using rule 4 (program_item -> import_stmt .)
    FLOAT           reduce using rule 4 (program_item -> import_stmt .)
    STRING          reduce using rule 4 (program_item -> import_stmt .)
    TRUE            reduce using rule 4 (program_item -> import_stmt .)
    FALSE           reduce using rule 4 (program_item -> import_stmt .)
    NULL            reduce using rule 4 (program_item -> import_stmt .)
    LBRACKET        reduce using rule 4 (program_item -> import_stmt .)
    $end            reduce using rule 4 (program_item -> import_stmt .)


state 5

    (5) program_item -> function_decl .

    IMPORT          reduce using rule 5 (program_item -> function_decl .)
    FN              reduce using rule 5 (program_item -> function_decl .)
    STRUCT          reduce using rule 5 (program_item -> function_decl .)
    LET             reduce using rule 5 (program_item -> function_decl .)
    IF              reduce using rule 5 (program_item -> function_decl .)
    WHILE           reduce using rule 5 (program_item -> function_decl .)
    FOR             reduce using rule 5 (program_item -> function_decl .)
    RETURN          reduce using rule 5 (program_item -> function_decl .)
    LBRACE          reduce using rule 5 (program_item -> function_decl .)
    ID              reduce using rule 5 (program_item -> function_decl .)
    NOT             reduce using rule 5 (program_item -> function_decl .)
    MINUS           reduce using rule 5 (program_item -> function_decl .)
    LPAREN          reduce using rule 5 (program_item -> function_decl .)
    INTEGER         reduce using rule 5 (program_item -> function_decl .)
    FLOAT           reduce using rule 5 (program_item -> function_decl .)
    STRING          reduce using rule 5 (program_item -> function_decl .)
    TRUE            reduce using rule 5 (program_item -> function_decl .)
    FALSE           reduce using rule 5 (program_item -> function_decl .)
    NULL            reduce using rule 5 (program_item -> function_decl .)
    LBRACKET        reduce using rule 5 (program_item -> function_decl .)
    $end            reduce using rule 5 (program_item -> function_decl .)


state 6

    (6) program_item -> struct_decl .

    IMPORT          reduce using rule 6 (program_item -> struct_decl .)
    FN              reduce using rule 6 (program_item -> struct_decl .)
    STRUCT          reduce using rule 6 (program_item -> struct_decl .)
    LET             reduce using rule 6 (program_item -> struct_decl .)
    IF              reduce using rule 6 (program_item -> struct_decl .)
    WHILE           reduce using rule 6 (program_item -> struct_decl .)
    FOR             reduce using rule 6 (program_item -> struct_decl .)
    RETURN          reduce using rule 6 (program_item -> struct_decl .)
    LBRACE          reduce using rule 6 (program_item -> struct_decl .)
    ID              reduce using rule 6 (program_item -> struct_decl .)
    NOT             reduce using rule 6 (program_item -> struct_decl .)
    MINUS           reduce using rule 6 (program_item -> struct_decl .)
    LPAREN          reduce using rule 6 (program_item -> struct_decl .)
    INTEGER         reduce using rule 6 (program_item -> struct_decl .)
    FLOAT           reduce using rule 6 (program_item -> struct_decl .)
    STRING          reduce using rule 6 (program_item -> struct_decl .)
    TRUE            reduce using rule 6 (program_item -> struct_decl .)
    FALSE           reduce using rule 6 (program_item -> struct_decl .)
    NULL            reduce using rule 6 (program_item -> struct_decl .)
    LBRACKET        reduce using rule 6 (program_item -> struct_decl .)
    $end            reduce using rule 6 (program_item -> struct_decl .)


state 7

    (7) program_item -> statement .

    IMPORT          reduce using rule 7 (program_item -> statement .)
    FN              reduce using rule 7 (program_item -> statement .)
    STRUCT          reduce using rule 7 (program_item -> statement .)
    LET             reduce using rule 7 (program_item -> statement .)
    IF              reduce using rule 7 (program_item -> statement .)
    WHILE           reduce using rule 7 (program_item -> statement .)
    FOR             reduce using rule 7 (program_item -> statement .)
    RETURN          reduce using rule 7 (program_item -> statement .)
    LBRACE          reduce using rule 7 (program_item -> statement .)
    ID              reduce using rule 7 (program_item -> statement .)
    NOT             reduce using rule 7 (program_item -> statement .)
    MINUS           reduce using rule 7 (program_item -> statement .)
    LPAREN          reduce using rule 7 (program_item -> statement .)
    INTEGER         reduce using rule 7 (program_item -> statement .)
    FLOAT           reduce using rule 7 (program_item -> statement .)
    STRING          reduce using rule 7 (program_item -> statement .)
    TRUE            reduce using rule 7 (program_item -> statement .)
    FALSE           reduce using rule 7 (program_item -> statement .)
    NULL            reduce using rule 7 (program_item -> statement .)
    LBRACKET        reduce using rule 7 (program_item -> statement .)
    $end            reduce using rule 7 (program_item -> statement .)


state 8

    (16) import_stmt -> IMPORT . STRING SEMICOLON

    STRING          shift and go to state 52


state 9

    (82) literal -> STRING .

    LPAREN          reduce using rule 82 (literal -> STRING .)
    DOT             reduce using rule 82 (literal -> STRING .)
    LBRACKET        reduce using rule 82 (literal -> STRING .)
    POWER           reduce using rule 82 (literal -> STRING .)
    TIMES           reduce using rule 82 (literal -> STRING .)
    DIVIDE          reduce using rule 82 (literal -> STRING .)
    MOD             reduce using rule 82 (literal -> STRING .)
    PLUS            reduce using rule 82 (literal -> STRING .)
    MINUS           reduce using rule 82 (literal -> STRING .)
    LT              reduce using rule 82 (literal -> STRING .)
    GT              reduce using rule 82 (literal -> STRING .)
    LE              reduce using rule 82 (literal -> STRING .)
    GE              reduce using rule 82 (literal -> STRING .)
    EQ              reduce using rule 82 (literal -> STRING .)
    NE              reduce using rule 82 (literal -> STRING .)
    AND             reduce using rule 82 (literal -> STRING .)
    OR              reduce using rule 82 (literal -> STRING .)
    SEMICOLON       reduce using rule 82 (literal -> STRING .)
    RPAREN          reduce using rule 82 (literal -> STRING .)
    LBRACE          reduce using rule 82 (literal -> STRING .)
    COMMA           reduce using rule 82 (literal -> STRING .)
    RBRACKET        reduce using rule 82 (literal -> STRING .)
    RBRACE          reduce using rule 82 (literal -> STRING .)


state 10

    (17) function_decl -> FN . ID LPAREN parameters_opt RPAREN block

    ID              shift and go to state 53


state 11

    (28) assign_target -> ID .
    (44) primary_expr -> ID .
    (90) struct_literal -> ID . LBRACE field_assignments_opt RBRACE

  ! reduce/reduce conflict for DOT resolved using rule 28 (assign_target -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 28 (assign_target -> ID .)
    ASSIGN          reduce using rule 28 (assign_target -> ID .)
    DOT             reduce using rule 28 (assign_target -> ID .)
    LBRACKET        reduce using rule 28 (assign_target -> ID .)
    LPAREN          reduce using rule 44 (primary_expr -> ID .)
    POWER           reduce using rule 44 (primary_expr -> ID .)
    TIMES           reduce using rule 44 (primary_expr -> ID .)
    DIVIDE          reduce using rule 44 (primary_expr -> ID .)
    MOD             reduce using rule 44 (primary_expr -> ID .)
    PLUS            reduce using rule 44 (primary_expr -> ID .)
    MINUS           reduce using rule 44 (primary_expr -> ID .)
    LT              reduce using rule 44 (primary_expr -> ID .)
    GT              reduce using rule 44 (primary_expr -> ID .)
    LE              reduce using rule 44 (primary_expr -> ID .)
    GE              reduce using rule 44 (primary_expr -> ID .)
    EQ              reduce using rule 44 (primary_expr -> ID .)
    NE              reduce using rule 44 (primary_expr -> ID .)
    AND             reduce using rule 44 (primary_expr -> ID .)
    OR              reduce using rule 44 (primary_expr -> ID .)
    SEMICOLON       reduce using rule 44 (primary_expr -> ID .)
    LBRACE          shift and go to state 54

  ! DOT             [ reduce using rule 44 (primary_expr -> ID .) ]
  ! LBRACKET        [ reduce using rule 44 (primary_expr -> ID .) ]


state 12

    (46) primary_expr -> LPAREN . expr RPAREN
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 55
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 13

    (15) statement -> block .

    IMPORT          reduce using rule 15 (statement -> block .)
    FN              reduce using rule 15 (statement -> block .)
    STRUCT          reduce using rule 15 (statement -> block .)
    LET             reduce using rule 15 (statement -> block .)
    IF              reduce using rule 15 (statement -> block .)
    WHILE           reduce using rule 15 (statement -> block .)
    FOR             reduce using rule 15 (statement -> block .)
    RETURN          reduce using rule 15 (statement -> block .)
    LBRACE          reduce using rule 15 (statement -> block .)
    ID              reduce using rule 15 (statement -> block .)
    NOT             reduce using rule 15 (statement -> block .)
    MINUS           reduce using rule 15 (statement -> block .)
    LPAREN          reduce using rule 15 (statement -> block .)
    INTEGER         reduce using rule 15 (statement -> block .)
    FLOAT           reduce using rule 15 (statement -> block .)
    STRING          reduce using rule 15 (statement -> block .)
    TRUE            reduce using rule 15 (statement -> block .)
    FALSE           reduce using rule 15 (statement -> block .)
    NULL            reduce using rule 15 (statement -> block .)
    LBRACKET        reduce using rule 15 (statement -> block .)
    $end            reduce using rule 15 (statement -> block .)
    RBRACE          reduce using rule 15 (statement -> block .)


state 14

    (22) struct_decl -> STRUCT . ID LBRACE struct_fields RBRACE SEMICOLON

    ID              shift and go to state 57


state 15

    (41) block -> LBRACE . statement_list RBRACE
    (42) statement_list -> . statement_list statement
    (43) statement_list -> . empty
    (101) empty -> .

    RBRACE          reduce using rule 101 (empty -> .)
    LET             reduce using rule 101 (empty -> .)
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    LBRACE          reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    NOT             reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    LPAREN          reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    TRUE            reduce using rule 101 (empty -> .)
    FALSE           reduce using rule 101 (empty -> .)
    NULL            reduce using rule 101 (empty -> .)
    LBRACKET        reduce using rule 101 (empty -> .)

    statement_list                 shift and go to state 58
    empty                          shift and go to state 59

state 16

    (8) statement -> variable_decl .

    IMPORT          reduce using rule 8 (statement -> variable_decl .)
    FN              reduce using rule 8 (statement -> variable_decl .)
    STRUCT          reduce using rule 8 (statement -> variable_decl .)
    LET             reduce using rule 8 (statement -> variable_decl .)
    IF              reduce using rule 8 (statement -> variable_decl .)
    WHILE           reduce using rule 8 (statement -> variable_decl .)
    FOR             reduce using rule 8 (statement -> variable_decl .)
    RETURN          reduce using rule 8 (statement -> variable_decl .)
    LBRACE          reduce using rule 8 (statement -> variable_decl .)
    ID              reduce using rule 8 (statement -> variable_decl .)
    NOT             reduce using rule 8 (statement -> variable_decl .)
    MINUS           reduce using rule 8 (statement -> variable_decl .)
    LPAREN          reduce using rule 8 (statement -> variable_decl .)
    INTEGER         reduce using rule 8 (statement -> variable_decl .)
    FLOAT           reduce using rule 8 (statement -> variable_decl .)
    STRING          reduce using rule 8 (statement -> variable_decl .)
    TRUE            reduce using rule 8 (statement -> variable_decl .)
    FALSE           reduce using rule 8 (statement -> variable_decl .)
    NULL            reduce using rule 8 (statement -> variable_decl .)
    LBRACKET        reduce using rule 8 (statement -> variable_decl .)
    $end            reduce using rule 8 (statement -> variable_decl .)
    RBRACE          reduce using rule 8 (statement -> variable_decl .)


state 17

    (9) statement -> assignment .

    IMPORT          reduce using rule 9 (statement -> assignment .)
    FN              reduce using rule 9 (statement -> assignment .)
    STRUCT          reduce using rule 9 (statement -> assignment .)
    LET             reduce using rule 9 (statement -> assignment .)
    IF              reduce using rule 9 (statement -> assignment .)
    WHILE           reduce using rule 9 (statement -> assignment .)
    FOR             reduce using rule 9 (statement -> assignment .)
    RETURN          reduce using rule 9 (statement -> assignment .)
    LBRACE          reduce using rule 9 (statement -> assignment .)
    ID              reduce using rule 9 (statement -> assignment .)
    NOT             reduce using rule 9 (statement -> assignment .)
    MINUS           reduce using rule 9 (statement -> assignment .)
    LPAREN          reduce using rule 9 (statement -> assignment .)
    INTEGER         reduce using rule 9 (statement -> assignment .)
    FLOAT           reduce using rule 9 (statement -> assignment .)
    STRING          reduce using rule 9 (statement -> assignment .)
    TRUE            reduce using rule 9 (statement -> assignment .)
    FALSE           reduce using rule 9 (statement -> assignment .)
    NULL            reduce using rule 9 (statement -> assignment .)
    LBRACKET        reduce using rule 9 (statement -> assignment .)
    $end            reduce using rule 9 (statement -> assignment .)
    RBRACE          reduce using rule 9 (statement -> assignment .)


state 18

    (10) statement -> if_stmt .

    IMPORT          reduce using rule 10 (statement -> if_stmt .)
    FN              reduce using rule 10 (statement -> if_stmt .)
    STRUCT          reduce using rule 10 (statement -> if_stmt .)
    LET             reduce using rule 10 (statement -> if_stmt .)
    IF              reduce using rule 10 (statement -> if_stmt .)
    WHILE           reduce using rule 10 (statement -> if_stmt .)
    FOR             reduce using rule 10 (statement -> if_stmt .)
    RETURN          reduce using rule 10 (statement -> if_stmt .)
    LBRACE          reduce using rule 10 (statement -> if_stmt .)
    ID              reduce using rule 10 (statement -> if_stmt .)
    NOT             reduce using rule 10 (statement -> if_stmt .)
    MINUS           reduce using rule 10 (statement -> if_stmt .)
    LPAREN          reduce using rule 10 (statement -> if_stmt .)
    INTEGER         reduce using rule 10 (statement -> if_stmt .)
    FLOAT           reduce using rule 10 (statement -> if_stmt .)
    STRING          reduce using rule 10 (statement -> if_stmt .)
    TRUE            reduce using rule 10 (statement -> if_stmt .)
    FALSE           reduce using rule 10 (statement -> if_stmt .)
    NULL            reduce using rule 10 (statement -> if_stmt .)
    LBRACKET        reduce using rule 10 (statement -> if_stmt .)
    $end            reduce using rule 10 (statement -> if_stmt .)
    RBRACE          reduce using rule 10 (statement -> if_stmt .)


state 19

    (11) statement -> while_stmt .

    IMPORT          reduce using rule 11 (statement -> while_stmt .)
    FN              reduce using rule 11 (statement -> while_stmt .)
    STRUCT          reduce using rule 11 (statement -> while_stmt .)
    LET             reduce using rule 11 (statement -> while_stmt .)
    IF              reduce using rule 11 (statement -> while_stmt .)
    WHILE           reduce using rule 11 (statement -> while_stmt .)
    FOR             reduce using rule 11 (statement -> while_stmt .)
    RETURN          reduce using rule 11 (statement -> while_stmt .)
    LBRACE          reduce using rule 11 (statement -> while_stmt .)
    ID              reduce using rule 11 (statement -> while_stmt .)
    NOT             reduce using rule 11 (statement -> while_stmt .)
    MINUS           reduce using rule 11 (statement -> while_stmt .)
    LPAREN          reduce using rule 11 (statement -> while_stmt .)
    INTEGER         reduce using rule 11 (statement -> while_stmt .)
    FLOAT           reduce using rule 11 (statement -> while_stmt .)
    STRING          reduce using rule 11 (statement -> while_stmt .)
    TRUE            reduce using rule 11 (statement -> while_stmt .)
    FALSE           reduce using rule 11 (statement -> while_stmt .)
    NULL            reduce using rule 11 (statement -> while_stmt .)
    LBRACKET        reduce using rule 11 (statement -> while_stmt .)
    $end            reduce using rule 11 (statement -> while_stmt .)
    RBRACE          reduce using rule 11 (statement -> while_stmt .)


state 20

    (12) statement -> for_stmt .

    IMPORT          reduce using rule 12 (statement -> for_stmt .)
    FN              reduce using rule 12 (statement -> for_stmt .)
    STRUCT          reduce using rule 12 (statement -> for_stmt .)
    LET             reduce using rule 12 (statement -> for_stmt .)
    IF              reduce using rule 12 (statement -> for_stmt .)
    WHILE           reduce using rule 12 (statement -> for_stmt .)
    FOR             reduce using rule 12 (statement -> for_stmt .)
    RETURN          reduce using rule 12 (statement -> for_stmt .)
    LBRACE          reduce using rule 12 (statement -> for_stmt .)
    ID              reduce using rule 12 (statement -> for_stmt .)
    NOT             reduce using rule 12 (statement -> for_stmt .)
    MINUS           reduce using rule 12 (statement -> for_stmt .)
    LPAREN          reduce using rule 12 (statement -> for_stmt .)
    INTEGER         reduce using rule 12 (statement -> for_stmt .)
    FLOAT           reduce using rule 12 (statement -> for_stmt .)
    STRING          reduce using rule 12 (statement -> for_stmt .)
    TRUE            reduce using rule 12 (statement -> for_stmt .)
    FALSE           reduce using rule 12 (statement -> for_stmt .)
    NULL            reduce using rule 12 (statement -> for_stmt .)
    LBRACKET        reduce using rule 12 (statement -> for_stmt .)
    $end            reduce using rule 12 (statement -> for_stmt .)
    RBRACE          reduce using rule 12 (statement -> for_stmt .)


state 21

    (13) statement -> return_stmt .

    IMPORT          reduce using rule 13 (statement -> return_stmt .)
    FN              reduce using rule 13 (statement -> return_stmt .)
    STRUCT          reduce using rule 13 (statement -> return_stmt .)
    LET             reduce using rule 13 (statement -> return_stmt .)
    IF              reduce using rule 13 (statement -> return_stmt .)
    WHILE           reduce using rule 13 (statement -> return_stmt .)
    FOR             reduce using rule 13 (statement -> return_stmt .)
    RETURN          reduce using rule 13 (statement -> return_stmt .)
    LBRACE          reduce using rule 13 (statement -> return_stmt .)
    ID              reduce using rule 13 (statement -> return_stmt .)
    NOT             reduce using rule 13 (statement -> return_stmt .)
    MINUS           reduce using rule 13 (statement -> return_stmt .)
    LPAREN          reduce using rule 13 (statement -> return_stmt .)
    INTEGER         reduce using rule 13 (statement -> return_stmt .)
    FLOAT           reduce using rule 13 (statement -> return_stmt .)
    STRING          reduce using rule 13 (statement -> return_stmt .)
    TRUE            reduce using rule 13 (statement -> return_stmt .)
    FALSE           reduce using rule 13 (statement -> return_stmt .)
    NULL            reduce using rule 13 (statement -> return_stmt .)
    LBRACKET        reduce using rule 13 (statement -> return_stmt .)
    $end            reduce using rule 13 (statement -> return_stmt .)
    RBRACE          reduce using rule 13 (statement -> return_stmt .)


state 22

    (14) statement -> expr_stmt .

    IMPORT          reduce using rule 14 (statement -> expr_stmt .)
    FN              reduce using rule 14 (statement -> expr_stmt .)
    STRUCT          reduce using rule 14 (statement -> expr_stmt .)
    LET             reduce using rule 14 (statement -> expr_stmt .)
    IF              reduce using rule 14 (statement -> expr_stmt .)
    WHILE           reduce using rule 14 (statement -> expr_stmt .)
    FOR             reduce using rule 14 (statement -> expr_stmt .)
    RETURN          reduce using rule 14 (statement -> expr_stmt .)
    LBRACE          reduce using rule 14 (statement -> expr_stmt .)
    ID              reduce using rule 14 (statement -> expr_stmt .)
    NOT             reduce using rule 14 (statement -> expr_stmt .)
    MINUS           reduce using rule 14 (statement -> expr_stmt .)
    LPAREN          reduce using rule 14 (statement -> expr_stmt .)
    INTEGER         reduce using rule 14 (statement -> expr_stmt .)
    FLOAT           reduce using rule 14 (statement -> expr_stmt .)
    STRING          reduce using rule 14 (statement -> expr_stmt .)
    TRUE            reduce using rule 14 (statement -> expr_stmt .)
    FALSE           reduce using rule 14 (statement -> expr_stmt .)
    NULL            reduce using rule 14 (statement -> expr_stmt .)
    LBRACKET        reduce using rule 14 (statement -> expr_stmt .)
    $end            reduce using rule 14 (statement -> expr_stmt .)
    RBRACE          reduce using rule 14 (statement -> expr_stmt .)


state 23

    (26) variable_decl -> LET . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 60


state 24

    (40) expr_stmt -> expr . SEMICOLON

    SEMICOLON       shift and go to state 61


state 25

    (27) assignment -> assign_target . ASSIGN expr SEMICOLON
    (29) assign_target -> assign_target . DOT ID
    (30) assign_target -> assign_target . LBRACKET expr RBRACKET

    ASSIGN          shift and go to state 62
    DOT             shift and go to state 63
    LBRACKET        shift and go to state 64


state 26

    (31) if_stmt -> IF . expr block elif_blocks else_block_opt
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 65
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 27

    (36) while_stmt -> WHILE . expr block
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 66
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 28

    (37) for_stmt -> FOR . ID IN expr block

    ID              shift and go to state 67


state 29

    (38) return_stmt -> RETURN . expr SEMICOLON
    (39) return_stmt -> RETURN . SEMICOLON
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    SEMICOLON       shift and go to state 69
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 68
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 30

    (96) array_literal -> LBRACKET . expr_list_opt RBRACKET
    (97) expr_list_opt -> . expr_list
    (98) expr_list_opt -> . empty
    (99) expr_list -> . expr
    (100) expr_list -> . expr_list COMMA expr
    (101) empty -> .
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    RBRACKET        reduce using rule 101 (empty -> .)
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr_list_opt                  shift and go to state 70
    expr_list                      shift and go to state 71
    empty                          shift and go to state 72
    expr                           shift and go to state 73
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 31

    (79) expr -> logical_or_expr .
    (78) logical_or_expr -> logical_or_expr . OR logical_and_expr

    SEMICOLON       reduce using rule 79 (expr -> logical_or_expr .)
    RPAREN          reduce using rule 79 (expr -> logical_or_expr .)
    LBRACE          reduce using rule 79 (expr -> logical_or_expr .)
    COMMA           reduce using rule 79 (expr -> logical_or_expr .)
    RBRACKET        reduce using rule 79 (expr -> logical_or_expr .)
    RBRACE          reduce using rule 79 (expr -> logical_or_expr .)
    OR              shift and go to state 74


state 32

    (77) logical_or_expr -> logical_and_expr .
    (76) logical_and_expr -> logical_and_expr . AND equality_expr

    OR              reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    SEMICOLON       reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    RPAREN          reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    LBRACE          reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    COMMA           reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    RBRACKET        reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    RBRACE          reduce using rule 77 (logical_or_expr -> logical_and_expr .)
    AND             shift and go to state 75


state 33

    (75) logical_and_expr -> equality_expr .
    (73) equality_expr -> equality_expr . EQ relational_expr
    (74) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 75 (logical_and_expr -> equality_expr .)
    OR              reduce using rule 75 (logical_and_expr -> equality_expr .)
    SEMICOLON       reduce using rule 75 (logical_and_expr -> equality_expr .)
    RPAREN          reduce using rule 75 (logical_and_expr -> equality_expr .)
    LBRACE          reduce using rule 75 (logical_and_expr -> equality_expr .)
    COMMA           reduce using rule 75 (logical_and_expr -> equality_expr .)
    RBRACKET        reduce using rule 75 (logical_and_expr -> equality_expr .)
    RBRACE          reduce using rule 75 (logical_and_expr -> equality_expr .)
    EQ              shift and go to state 76
    NE              shift and go to state 77


state 34

    (72) equality_expr -> relational_expr .
    (68) relational_expr -> relational_expr . LT additive_expr
    (69) relational_expr -> relational_expr . GT additive_expr
    (70) relational_expr -> relational_expr . LE additive_expr
    (71) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 72 (equality_expr -> relational_expr .)
    NE              reduce using rule 72 (equality_expr -> relational_expr .)
    AND             reduce using rule 72 (equality_expr -> relational_expr .)
    OR              reduce using rule 72 (equality_expr -> relational_expr .)
    SEMICOLON       reduce using rule 72 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 72 (equality_expr -> relational_expr .)
    LBRACE          reduce using rule 72 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 72 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 72 (equality_expr -> relational_expr .)
    RBRACE          reduce using rule 72 (equality_expr -> relational_expr .)
    LT              shift and go to state 78
    GT              shift and go to state 79
    LE              shift and go to state 80
    GE              shift and go to state 81


state 35

    (67) relational_expr -> additive_expr .
    (65) additive_expr -> additive_expr . PLUS multiplicative_expr
    (66) additive_expr -> additive_expr . MINUS multiplicative_expr

    LT              reduce using rule 67 (relational_expr -> additive_expr .)
    GT              reduce using rule 67 (relational_expr -> additive_expr .)
    LE              reduce using rule 67 (relational_expr -> additive_expr .)
    GE              reduce using rule 67 (relational_expr -> additive_expr .)
    EQ              reduce using rule 67 (relational_expr -> additive_expr .)
    NE              reduce using rule 67 (relational_expr -> additive_expr .)
    AND             reduce using rule 67 (relational_expr -> additive_expr .)
    OR              reduce using rule 67 (relational_expr -> additive_expr .)
    SEMICOLON       reduce using rule 67 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 67 (relational_expr -> additive_expr .)
    LBRACE          reduce using rule 67 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 67 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 67 (relational_expr -> additive_expr .)
    RBRACE          reduce using rule 67 (relational_expr -> additive_expr .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 36

    (64) additive_expr -> multiplicative_expr .
    (61) multiplicative_expr -> multiplicative_expr . TIMES exponential_expr
    (62) multiplicative_expr -> multiplicative_expr . DIVIDE exponential_expr
    (63) multiplicative_expr -> multiplicative_expr . MOD exponential_expr

    PLUS            reduce using rule 64 (additive_expr -> multiplicative_expr .)
    MINUS           reduce using rule 64 (additive_expr -> multiplicative_expr .)
    LT              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    GT              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    LE              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    GE              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    EQ              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    NE              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 64 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 64 (additive_expr -> multiplicative_expr .)
    SEMICOLON       reduce using rule 64 (additive_expr -> multiplicative_expr .)
    RPAREN          reduce using rule 64 (additive_expr -> multiplicative_expr .)
    LBRACE          reduce using rule 64 (additive_expr -> multiplicative_expr .)
    COMMA           reduce using rule 64 (additive_expr -> multiplicative_expr .)
    RBRACKET        reduce using rule 64 (additive_expr -> multiplicative_expr .)
    RBRACE          reduce using rule 64 (additive_expr -> multiplicative_expr .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 37

    (56) unary_expr -> MINUS . unary_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    unary_expr                     shift and go to state 87
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 38

    (60) multiplicative_expr -> exponential_expr .

    TIMES           reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    DIVIDE          reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    MOD             reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    PLUS            reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    MINUS           reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    LT              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    GT              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    LE              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    GE              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    EQ              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    NE              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    AND             reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    OR              reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    SEMICOLON       reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    RPAREN          reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    LBRACE          reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    COMMA           reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    RBRACKET        reduce using rule 60 (multiplicative_expr -> exponential_expr .)
    RBRACE          reduce using rule 60 (multiplicative_expr -> exponential_expr .)


state 39

    (58) exponential_expr -> unary_expr .
    (59) exponential_expr -> unary_expr . POWER exponential_expr

    TIMES           reduce using rule 58 (exponential_expr -> unary_expr .)
    DIVIDE          reduce using rule 58 (exponential_expr -> unary_expr .)
    MOD             reduce using rule 58 (exponential_expr -> unary_expr .)
    PLUS            reduce using rule 58 (exponential_expr -> unary_expr .)
    MINUS           reduce using rule 58 (exponential_expr -> unary_expr .)
    LT              reduce using rule 58 (exponential_expr -> unary_expr .)
    GT              reduce using rule 58 (exponential_expr -> unary_expr .)
    LE              reduce using rule 58 (exponential_expr -> unary_expr .)
    GE              reduce using rule 58 (exponential_expr -> unary_expr .)
    EQ              reduce using rule 58 (exponential_expr -> unary_expr .)
    NE              reduce using rule 58 (exponential_expr -> unary_expr .)
    AND             reduce using rule 58 (exponential_expr -> unary_expr .)
    OR              reduce using rule 58 (exponential_expr -> unary_expr .)
    SEMICOLON       reduce using rule 58 (exponential_expr -> unary_expr .)
    RPAREN          reduce using rule 58 (exponential_expr -> unary_expr .)
    LBRACE          reduce using rule 58 (exponential_expr -> unary_expr .)
    COMMA           reduce using rule 58 (exponential_expr -> unary_expr .)
    RBRACKET        reduce using rule 58 (exponential_expr -> unary_expr .)
    RBRACE          reduce using rule 58 (exponential_expr -> unary_expr .)
    POWER           shift and go to state 88


state 40

    (55) unary_expr -> NOT . unary_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    unary_expr                     shift and go to state 89
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 41

    (57) unary_expr -> postfix_expr .

    POWER           reduce using rule 57 (unary_expr -> postfix_expr .)
    TIMES           reduce using rule 57 (unary_expr -> postfix_expr .)
    DIVIDE          reduce using rule 57 (unary_expr -> postfix_expr .)
    MOD             reduce using rule 57 (unary_expr -> postfix_expr .)
    PLUS            reduce using rule 57 (unary_expr -> postfix_expr .)
    MINUS           reduce using rule 57 (unary_expr -> postfix_expr .)
    LT              reduce using rule 57 (unary_expr -> postfix_expr .)
    GT              reduce using rule 57 (unary_expr -> postfix_expr .)
    LE              reduce using rule 57 (unary_expr -> postfix_expr .)
    GE              reduce using rule 57 (unary_expr -> postfix_expr .)
    EQ              reduce using rule 57 (unary_expr -> postfix_expr .)
    NE              reduce using rule 57 (unary_expr -> postfix_expr .)
    AND             reduce using rule 57 (unary_expr -> postfix_expr .)
    OR              reduce using rule 57 (unary_expr -> postfix_expr .)
    SEMICOLON       reduce using rule 57 (unary_expr -> postfix_expr .)
    RPAREN          reduce using rule 57 (unary_expr -> postfix_expr .)
    LBRACE          reduce using rule 57 (unary_expr -> postfix_expr .)
    COMMA           reduce using rule 57 (unary_expr -> postfix_expr .)
    RBRACKET        reduce using rule 57 (unary_expr -> postfix_expr .)
    RBRACE          reduce using rule 57 (unary_expr -> postfix_expr .)


state 42

    (49) postfix_expr -> primary_expr . postfix_chain
    (50) postfix_chain -> . postfix postfix_chain
    (51) postfix_chain -> . empty
    (52) postfix -> . LPAREN args_opt RPAREN
    (53) postfix -> . DOT ID
    (54) postfix -> . LBRACKET expr RBRACKET
    (101) empty -> .

    LPAREN          shift and go to state 93
    DOT             shift and go to state 94
    LBRACKET        shift and go to state 95
    POWER           reduce using rule 101 (empty -> .)
    TIMES           reduce using rule 101 (empty -> .)
    DIVIDE          reduce using rule 101 (empty -> .)
    MOD             reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    LT              reduce using rule 101 (empty -> .)
    GT              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    LBRACE          reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)
    RBRACKET        reduce using rule 101 (empty -> .)
    RBRACE          reduce using rule 101 (empty -> .)

    postfix_chain                  shift and go to state 90
    postfix                        shift and go to state 91
    empty                          shift and go to state 92

state 43

    (45) primary_expr -> literal .

    LPAREN          reduce using rule 45 (primary_expr -> literal .)
    DOT             reduce using rule 45 (primary_expr -> literal .)
    LBRACKET        reduce using rule 45 (primary_expr -> literal .)
    POWER           reduce using rule 45 (primary_expr -> literal .)
    TIMES           reduce using rule 45 (primary_expr -> literal .)
    DIVIDE          reduce using rule 45 (primary_expr -> literal .)
    MOD             reduce using rule 45 (primary_expr -> literal .)
    PLUS            reduce using rule 45 (primary_expr -> literal .)
    MINUS           reduce using rule 45 (primary_expr -> literal .)
    LT              reduce using rule 45 (primary_expr -> literal .)
    GT              reduce using rule 45 (primary_expr -> literal .)
    LE              reduce using rule 45 (primary_expr -> literal .)
    GE              reduce using rule 45 (primary_expr -> literal .)
    EQ              reduce using rule 45 (primary_expr -> literal .)
    NE              reduce using rule 45 (primary_expr -> literal .)
    AND             reduce using rule 45 (primary_expr -> literal .)
    OR              reduce using rule 45 (primary_expr -> literal .)
    SEMICOLON       reduce using rule 45 (primary_expr -> literal .)
    RPAREN          reduce using rule 45 (primary_expr -> literal .)
    LBRACE          reduce using rule 45 (primary_expr -> literal .)
    COMMA           reduce using rule 45 (primary_expr -> literal .)
    RBRACKET        reduce using rule 45 (primary_expr -> literal .)
    RBRACE          reduce using rule 45 (primary_expr -> literal .)


state 44

    (47) primary_expr -> struct_literal .

    LPAREN          reduce using rule 47 (primary_expr -> struct_literal .)
    DOT             reduce using rule 47 (primary_expr -> struct_literal .)
    LBRACKET        reduce using rule 47 (primary_expr -> struct_literal .)
    POWER           reduce using rule 47 (primary_expr -> struct_literal .)
    TIMES           reduce using rule 47 (primary_expr -> struct_literal .)
    DIVIDE          reduce using rule 47 (primary_expr -> struct_literal .)
    MOD             reduce using rule 47 (primary_expr -> struct_literal .)
    PLUS            reduce using rule 47 (primary_expr -> struct_literal .)
    MINUS           reduce using rule 47 (primary_expr -> struct_literal .)
    LT              reduce using rule 47 (primary_expr -> struct_literal .)
    GT              reduce using rule 47 (primary_expr -> struct_literal .)
    LE              reduce using rule 47 (primary_expr -> struct_literal .)
    GE              reduce using rule 47 (primary_expr -> struct_literal .)
    EQ              reduce using rule 47 (primary_expr -> struct_literal .)
    NE              reduce using rule 47 (primary_expr -> struct_literal .)
    AND             reduce using rule 47 (primary_expr -> struct_literal .)
    OR              reduce using rule 47 (primary_expr -> struct_literal .)
    SEMICOLON       reduce using rule 47 (primary_expr -> struct_literal .)
    RPAREN          reduce using rule 47 (primary_expr -> struct_literal .)
    LBRACE          reduce using rule 47 (primary_expr -> struct_literal .)
    COMMA           reduce using rule 47 (primary_expr -> struct_literal .)
    RBRACKET        reduce using rule 47 (primary_expr -> struct_literal .)
    RBRACE          reduce using rule 47 (primary_expr -> struct_literal .)


state 45

    (48) primary_expr -> array_literal .

    LPAREN          reduce using rule 48 (primary_expr -> array_literal .)
    DOT             reduce using rule 48 (primary_expr -> array_literal .)
    LBRACKET        reduce using rule 48 (primary_expr -> array_literal .)
    POWER           reduce using rule 48 (primary_expr -> array_literal .)
    TIMES           reduce using rule 48 (primary_expr -> array_literal .)
    DIVIDE          reduce using rule 48 (primary_expr -> array_literal .)
    MOD             reduce using rule 48 (primary_expr -> array_literal .)
    PLUS            reduce using rule 48 (primary_expr -> array_literal .)
    MINUS           reduce using rule 48 (primary_expr -> array_literal .)
    LT              reduce using rule 48 (primary_expr -> array_literal .)
    GT              reduce using rule 48 (primary_expr -> array_literal .)
    LE              reduce using rule 48 (primary_expr -> array_literal .)
    GE              reduce using rule 48 (primary_expr -> array_literal .)
    EQ              reduce using rule 48 (primary_expr -> array_literal .)
    NE              reduce using rule 48 (primary_expr -> array_literal .)
    AND             reduce using rule 48 (primary_expr -> array_literal .)
    OR              reduce using rule 48 (primary_expr -> array_literal .)
    SEMICOLON       reduce using rule 48 (primary_expr -> array_literal .)
    RPAREN          reduce using rule 48 (primary_expr -> array_literal .)
    LBRACE          reduce using rule 48 (primary_expr -> array_literal .)
    COMMA           reduce using rule 48 (primary_expr -> array_literal .)
    RBRACKET        reduce using rule 48 (primary_expr -> array_literal .)
    RBRACE          reduce using rule 48 (primary_expr -> array_literal .)


state 46

    (80) literal -> INTEGER .

    LPAREN          reduce using rule 80 (literal -> INTEGER .)
    DOT             reduce using rule 80 (literal -> INTEGER .)
    LBRACKET        reduce using rule 80 (literal -> INTEGER .)
    POWER           reduce using rule 80 (literal -> INTEGER .)
    TIMES           reduce using rule 80 (literal -> INTEGER .)
    DIVIDE          reduce using rule 80 (literal -> INTEGER .)
    MOD             reduce using rule 80 (literal -> INTEGER .)
    PLUS            reduce using rule 80 (literal -> INTEGER .)
    MINUS           reduce using rule 80 (literal -> INTEGER .)
    LT              reduce using rule 80 (literal -> INTEGER .)
    GT              reduce using rule 80 (literal -> INTEGER .)
    LE              reduce using rule 80 (literal -> INTEGER .)
    GE              reduce using rule 80 (literal -> INTEGER .)
    EQ              reduce using rule 80 (literal -> INTEGER .)
    NE              reduce using rule 80 (literal -> INTEGER .)
    AND             reduce using rule 80 (literal -> INTEGER .)
    OR              reduce using rule 80 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 80 (literal -> INTEGER .)
    RPAREN          reduce using rule 80 (literal -> INTEGER .)
    LBRACE          reduce using rule 80 (literal -> INTEGER .)
    COMMA           reduce using rule 80 (literal -> INTEGER .)
    RBRACKET        reduce using rule 80 (literal -> INTEGER .)
    RBRACE          reduce using rule 80 (literal -> INTEGER .)


state 47

    (81) literal -> FLOAT .

    LPAREN          reduce using rule 81 (literal -> FLOAT .)
    DOT             reduce using rule 81 (literal -> FLOAT .)
    LBRACKET        reduce using rule 81 (literal -> FLOAT .)
    POWER           reduce using rule 81 (literal -> FLOAT .)
    TIMES           reduce using rule 81 (literal -> FLOAT .)
    DIVIDE          reduce using rule 81 (literal -> FLOAT .)
    MOD             reduce using rule 81 (literal -> FLOAT .)
    PLUS            reduce using rule 81 (literal -> FLOAT .)
    MINUS           reduce using rule 81 (literal -> FLOAT .)
    LT              reduce using rule 81 (literal -> FLOAT .)
    GT              reduce using rule 81 (literal -> FLOAT .)
    LE              reduce using rule 81 (literal -> FLOAT .)
    GE              reduce using rule 81 (literal -> FLOAT .)
    EQ              reduce using rule 81 (literal -> FLOAT .)
    NE              reduce using rule 81 (literal -> FLOAT .)
    AND             reduce using rule 81 (literal -> FLOAT .)
    OR              reduce using rule 81 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 81 (literal -> FLOAT .)
    RPAREN          reduce using rule 81 (literal -> FLOAT .)
    LBRACE          reduce using rule 81 (literal -> FLOAT .)
    COMMA           reduce using rule 81 (literal -> FLOAT .)
    RBRACKET        reduce using rule 81 (literal -> FLOAT .)
    RBRACE          reduce using rule 81 (literal -> FLOAT .)


state 48

    (83) literal -> TRUE .

    LPAREN          reduce using rule 83 (literal -> TRUE .)
    DOT             reduce using rule 83 (literal -> TRUE .)
    LBRACKET        reduce using rule 83 (literal -> TRUE .)
    POWER           reduce using rule 83 (literal -> TRUE .)
    TIMES           reduce using rule 83 (literal -> TRUE .)
    DIVIDE          reduce using rule 83 (literal -> TRUE .)
    MOD             reduce using rule 83 (literal -> TRUE .)
    PLUS            reduce using rule 83 (literal -> TRUE .)
    MINUS           reduce using rule 83 (literal -> TRUE .)
    LT              reduce using rule 83 (literal -> TRUE .)
    GT              reduce using rule 83 (literal -> TRUE .)
    LE              reduce using rule 83 (literal -> TRUE .)
    GE              reduce using rule 83 (literal -> TRUE .)
    EQ              reduce using rule 83 (literal -> TRUE .)
    NE              reduce using rule 83 (literal -> TRUE .)
    AND             reduce using rule 83 (literal -> TRUE .)
    OR              reduce using rule 83 (literal -> TRUE .)
    SEMICOLON       reduce using rule 83 (literal -> TRUE .)
    RPAREN          reduce using rule 83 (literal -> TRUE .)
    LBRACE          reduce using rule 83 (literal -> TRUE .)
    COMMA           reduce using rule 83 (literal -> TRUE .)
    RBRACKET        reduce using rule 83 (literal -> TRUE .)
    RBRACE          reduce using rule 83 (literal -> TRUE .)


state 49

    (84) literal -> FALSE .

    LPAREN          reduce using rule 84 (literal -> FALSE .)
    DOT             reduce using rule 84 (literal -> FALSE .)
    LBRACKET        reduce using rule 84 (literal -> FALSE .)
    POWER           reduce using rule 84 (literal -> FALSE .)
    TIMES           reduce using rule 84 (literal -> FALSE .)
    DIVIDE          reduce using rule 84 (literal -> FALSE .)
    MOD             reduce using rule 84 (literal -> FALSE .)
    PLUS            reduce using rule 84 (literal -> FALSE .)
    MINUS           reduce using rule 84 (literal -> FALSE .)
    LT              reduce using rule 84 (literal -> FALSE .)
    GT              reduce using rule 84 (literal -> FALSE .)
    LE              reduce using rule 84 (literal -> FALSE .)
    GE              reduce using rule 84 (literal -> FALSE .)
    EQ              reduce using rule 84 (literal -> FALSE .)
    NE              reduce using rule 84 (literal -> FALSE .)
    AND             reduce using rule 84 (literal -> FALSE .)
    OR              reduce using rule 84 (literal -> FALSE .)
    SEMICOLON       reduce using rule 84 (literal -> FALSE .)
    RPAREN          reduce using rule 84 (literal -> FALSE .)
    LBRACE          reduce using rule 84 (literal -> FALSE .)
    COMMA           reduce using rule 84 (literal -> FALSE .)
    RBRACKET        reduce using rule 84 (literal -> FALSE .)
    RBRACE          reduce using rule 84 (literal -> FALSE .)


state 50

    (85) literal -> NULL .

    LPAREN          reduce using rule 85 (literal -> NULL .)
    DOT             reduce using rule 85 (literal -> NULL .)
    LBRACKET        reduce using rule 85 (literal -> NULL .)
    POWER           reduce using rule 85 (literal -> NULL .)
    TIMES           reduce using rule 85 (literal -> NULL .)
    DIVIDE          reduce using rule 85 (literal -> NULL .)
    MOD             reduce using rule 85 (literal -> NULL .)
    PLUS            reduce using rule 85 (literal -> NULL .)
    MINUS           reduce using rule 85 (literal -> NULL .)
    LT              reduce using rule 85 (literal -> NULL .)
    GT              reduce using rule 85 (literal -> NULL .)
    LE              reduce using rule 85 (literal -> NULL .)
    GE              reduce using rule 85 (literal -> NULL .)
    EQ              reduce using rule 85 (literal -> NULL .)
    NE              reduce using rule 85 (literal -> NULL .)
    AND             reduce using rule 85 (literal -> NULL .)
    OR              reduce using rule 85 (literal -> NULL .)
    SEMICOLON       reduce using rule 85 (literal -> NULL .)
    RPAREN          reduce using rule 85 (literal -> NULL .)
    LBRACE          reduce using rule 85 (literal -> NULL .)
    COMMA           reduce using rule 85 (literal -> NULL .)
    RBRACKET        reduce using rule 85 (literal -> NULL .)
    RBRACE          reduce using rule 85 (literal -> NULL .)


state 51

    (2) program_items -> program_items program_item .

    IMPORT          reduce using rule 2 (program_items -> program_items program_item .)
    FN              reduce using rule 2 (program_items -> program_items program_item .)
    STRUCT          reduce using rule 2 (program_items -> program_items program_item .)
    LET             reduce using rule 2 (program_items -> program_items program_item .)
    IF              reduce using rule 2 (program_items -> program_items program_item .)
    WHILE           reduce using rule 2 (program_items -> program_items program_item .)
    FOR             reduce using rule 2 (program_items -> program_items program_item .)
    RETURN          reduce using rule 2 (program_items -> program_items program_item .)
    LBRACE          reduce using rule 2 (program_items -> program_items program_item .)
    ID              reduce using rule 2 (program_items -> program_items program_item .)
    NOT             reduce using rule 2 (program_items -> program_items program_item .)
    MINUS           reduce using rule 2 (program_items -> program_items program_item .)
    LPAREN          reduce using rule 2 (program_items -> program_items program_item .)
    INTEGER         reduce using rule 2 (program_items -> program_items program_item .)
    FLOAT           reduce using rule 2 (program_items -> program_items program_item .)
    STRING          reduce using rule 2 (program_items -> program_items program_item .)
    TRUE            reduce using rule 2 (program_items -> program_items program_item .)
    FALSE           reduce using rule 2 (program_items -> program_items program_item .)
    NULL            reduce using rule 2 (program_items -> program_items program_item .)
    LBRACKET        reduce using rule 2 (program_items -> program_items program_item .)
    $end            reduce using rule 2 (program_items -> program_items program_item .)


state 52

    (16) import_stmt -> IMPORT STRING . SEMICOLON

    SEMICOLON       shift and go to state 96


state 53

    (17) function_decl -> FN ID . LPAREN parameters_opt RPAREN block

    LPAREN          shift and go to state 97


state 54

    (90) struct_literal -> ID LBRACE . field_assignments_opt RBRACE
    (91) field_assignments_opt -> . field_assignments
    (92) field_assignments_opt -> . empty
    (93) field_assignments -> . field_assign
    (94) field_assignments -> . field_assignments COMMA field_assign
    (101) empty -> .
    (95) field_assign -> . ID COLON expr

    RBRACE          reduce using rule 101 (empty -> .)
    ID              shift and go to state 98

    field_assignments_opt          shift and go to state 99
    field_assignments              shift and go to state 100
    empty                          shift and go to state 101
    field_assign                   shift and go to state 102

state 55

    (46) primary_expr -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 103


state 56

    (44) primary_expr -> ID .
    (90) struct_literal -> ID . LBRACE field_assignments_opt RBRACE

  ! shift/reduce conflict for LBRACE resolved as shift
    LPAREN          reduce using rule 44 (primary_expr -> ID .)
    DOT             reduce using rule 44 (primary_expr -> ID .)
    LBRACKET        reduce using rule 44 (primary_expr -> ID .)
    POWER           reduce using rule 44 (primary_expr -> ID .)
    TIMES           reduce using rule 44 (primary_expr -> ID .)
    DIVIDE          reduce using rule 44 (primary_expr -> ID .)
    MOD             reduce using rule 44 (primary_expr -> ID .)
    PLUS            reduce using rule 44 (primary_expr -> ID .)
    MINUS           reduce using rule 44 (primary_expr -> ID .)
    LT              reduce using rule 44 (primary_expr -> ID .)
    GT              reduce using rule 44 (primary_expr -> ID .)
    LE              reduce using rule 44 (primary_expr -> ID .)
    GE              reduce using rule 44 (primary_expr -> ID .)
    EQ              reduce using rule 44 (primary_expr -> ID .)
    NE              reduce using rule 44 (primary_expr -> ID .)
    AND             reduce using rule 44 (primary_expr -> ID .)
    OR              reduce using rule 44 (primary_expr -> ID .)
    RPAREN          reduce using rule 44 (primary_expr -> ID .)
    SEMICOLON       reduce using rule 44 (primary_expr -> ID .)
    COMMA           reduce using rule 44 (primary_expr -> ID .)
    RBRACKET        reduce using rule 44 (primary_expr -> ID .)
    RBRACE          reduce using rule 44 (primary_expr -> ID .)
    LBRACE          shift and go to state 54

  ! LBRACE          [ reduce using rule 44 (primary_expr -> ID .) ]


state 57

    (22) struct_decl -> STRUCT ID . LBRACE struct_fields RBRACE SEMICOLON

    LBRACE          shift and go to state 104


state 58

    (41) block -> LBRACE statement_list . RBRACE
    (42) statement_list -> statement_list . statement
    (8) statement -> . variable_decl
    (9) statement -> . assignment
    (10) statement -> . if_stmt
    (11) statement -> . while_stmt
    (12) statement -> . for_stmt
    (13) statement -> . return_stmt
    (14) statement -> . expr_stmt
    (15) statement -> . block
    (26) variable_decl -> . LET ID ASSIGN expr SEMICOLON
    (27) assignment -> . assign_target ASSIGN expr SEMICOLON
    (31) if_stmt -> . IF expr block elif_blocks else_block_opt
    (36) while_stmt -> . WHILE expr block
    (37) for_stmt -> . FOR ID IN expr block
    (38) return_stmt -> . RETURN expr SEMICOLON
    (39) return_stmt -> . RETURN SEMICOLON
    (40) expr_stmt -> . expr SEMICOLON
    (41) block -> . LBRACE statement_list RBRACE
    (28) assign_target -> . ID
    (29) assign_target -> . assign_target DOT ID
    (30) assign_target -> . assign_target LBRACKET expr RBRACKET
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    RBRACE          shift and go to state 105
    LET             shift and go to state 23
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 29
    LBRACE          shift and go to state 15
    ID              shift and go to state 11
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    statement                      shift and go to state 106
    variable_decl                  shift and go to state 16
    assignment                     shift and go to state 17
    if_stmt                        shift and go to state 18
    while_stmt                     shift and go to state 19
    for_stmt                       shift and go to state 20
    return_stmt                    shift and go to state 21
    expr_stmt                      shift and go to state 22
    block                          shift and go to state 13
    expr                           shift and go to state 24
    assign_target                  shift and go to state 25
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 59

    (43) statement_list -> empty .

    RBRACE          reduce using rule 43 (statement_list -> empty .)
    LET             reduce using rule 43 (statement_list -> empty .)
    IF              reduce using rule 43 (statement_list -> empty .)
    WHILE           reduce using rule 43 (statement_list -> empty .)
    FOR             reduce using rule 43 (statement_list -> empty .)
    RETURN          reduce using rule 43 (statement_list -> empty .)
    LBRACE          reduce using rule 43 (statement_list -> empty .)
    ID              reduce using rule 43 (statement_list -> empty .)
    NOT             reduce using rule 43 (statement_list -> empty .)
    MINUS           reduce using rule 43 (statement_list -> empty .)
    LPAREN          reduce using rule 43 (statement_list -> empty .)
    INTEGER         reduce using rule 43 (statement_list -> empty .)
    FLOAT           reduce using rule 43 (statement_list -> empty .)
    STRING          reduce using rule 43 (statement_list -> empty .)
    TRUE            reduce using rule 43 (statement_list -> empty .)
    FALSE           reduce using rule 43 (statement_list -> empty .)
    NULL            reduce using rule 43 (statement_list -> empty .)
    LBRACKET        reduce using rule 43 (statement_list -> empty .)


state 60

    (26) variable_decl -> LET ID . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 107


state 61

    (40) expr_stmt -> expr SEMICOLON .

    IMPORT          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    FN              reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    STRUCT          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    LET             reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    IF              reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    FOR             reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    ID              reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    NOT             reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    INTEGER         reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    STRING          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    TRUE            reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    FALSE           reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    NULL            reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    LBRACKET        reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    $end            reduce using rule 40 (expr_stmt -> expr SEMICOLON .)
    RBRACE          reduce using rule 40 (expr_stmt -> expr SEMICOLON .)


state 62

    (27) assignment -> assign_target ASSIGN . expr SEMICOLON
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 108
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 63

    (29) assign_target -> assign_target DOT . ID

    ID              shift and go to state 109


state 64

    (30) assign_target -> assign_target LBRACKET . expr RBRACKET
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 110
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 65

    (31) if_stmt -> IF expr . block elif_blocks else_block_opt
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 111

state 66

    (36) while_stmt -> WHILE expr . block
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 112

state 67

    (37) for_stmt -> FOR ID . IN expr block

    IN              shift and go to state 113


state 68

    (38) return_stmt -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 114


state 69

    (39) return_stmt -> RETURN SEMICOLON .

    IMPORT          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    FN              reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    STRUCT          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    LET             reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    LBRACKET        reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    $end            reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 39 (return_stmt -> RETURN SEMICOLON .)


state 70

    (96) array_literal -> LBRACKET expr_list_opt . RBRACKET

    RBRACKET        shift and go to state 115


state 71

    (97) expr_list_opt -> expr_list .
    (100) expr_list -> expr_list . COMMA expr

    RBRACKET        reduce using rule 97 (expr_list_opt -> expr_list .)
    COMMA           shift and go to state 116


state 72

    (98) expr_list_opt -> empty .

    RBRACKET        reduce using rule 98 (expr_list_opt -> empty .)


state 73

    (99) expr_list -> expr .

    COMMA           reduce using rule 99 (expr_list -> expr .)
    RBRACKET        reduce using rule 99 (expr_list -> expr .)


state 74

    (78) logical_or_expr -> logical_or_expr OR . logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    logical_and_expr               shift and go to state 117
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 75

    (76) logical_and_expr -> logical_and_expr AND . equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    equality_expr                  shift and go to state 118
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 76

    (73) equality_expr -> equality_expr EQ . relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    relational_expr                shift and go to state 119
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 77

    (74) equality_expr -> equality_expr NE . relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    relational_expr                shift and go to state 120
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 78

    (68) relational_expr -> relational_expr LT . additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    additive_expr                  shift and go to state 121
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 79

    (69) relational_expr -> relational_expr GT . additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    additive_expr                  shift and go to state 122
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 80

    (70) relational_expr -> relational_expr LE . additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    additive_expr                  shift and go to state 123
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 81

    (71) relational_expr -> relational_expr GE . additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    additive_expr                  shift and go to state 124
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 82

    (65) additive_expr -> additive_expr PLUS . multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    multiplicative_expr            shift and go to state 125
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 83

    (66) additive_expr -> additive_expr MINUS . multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    multiplicative_expr            shift and go to state 126
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 84

    (61) multiplicative_expr -> multiplicative_expr TIMES . exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    exponential_expr               shift and go to state 127
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 85

    (62) multiplicative_expr -> multiplicative_expr DIVIDE . exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    exponential_expr               shift and go to state 128
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 86

    (63) multiplicative_expr -> multiplicative_expr MOD . exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    exponential_expr               shift and go to state 129
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 87

    (56) unary_expr -> MINUS unary_expr .

    POWER           reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    TIMES           reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    DIVIDE          reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    MOD             reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    PLUS            reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    MINUS           reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    LT              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    GT              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    LE              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    GE              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    EQ              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    NE              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    AND             reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    OR              reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    SEMICOLON       reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    RPAREN          reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    LBRACE          reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    COMMA           reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    RBRACKET        reduce using rule 56 (unary_expr -> MINUS unary_expr .)
    RBRACE          reduce using rule 56 (unary_expr -> MINUS unary_expr .)


state 88

    (59) exponential_expr -> unary_expr POWER . exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    unary_expr                     shift and go to state 39
    exponential_expr               shift and go to state 130
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 89

    (55) unary_expr -> NOT unary_expr .

    POWER           reduce using rule 55 (unary_expr -> NOT unary_expr .)
    TIMES           reduce using rule 55 (unary_expr -> NOT unary_expr .)
    DIVIDE          reduce using rule 55 (unary_expr -> NOT unary_expr .)
    MOD             reduce using rule 55 (unary_expr -> NOT unary_expr .)
    PLUS            reduce using rule 55 (unary_expr -> NOT unary_expr .)
    MINUS           reduce using rule 55 (unary_expr -> NOT unary_expr .)
    LT              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    GT              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    LE              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    GE              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    EQ              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    NE              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    AND             reduce using rule 55 (unary_expr -> NOT unary_expr .)
    OR              reduce using rule 55 (unary_expr -> NOT unary_expr .)
    SEMICOLON       reduce using rule 55 (unary_expr -> NOT unary_expr .)
    RPAREN          reduce using rule 55 (unary_expr -> NOT unary_expr .)
    LBRACE          reduce using rule 55 (unary_expr -> NOT unary_expr .)
    COMMA           reduce using rule 55 (unary_expr -> NOT unary_expr .)
    RBRACKET        reduce using rule 55 (unary_expr -> NOT unary_expr .)
    RBRACE          reduce using rule 55 (unary_expr -> NOT unary_expr .)


state 90

    (49) postfix_expr -> primary_expr postfix_chain .

    POWER           reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    TIMES           reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    DIVIDE          reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    MOD             reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    PLUS            reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    MINUS           reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    LT              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    GT              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    LE              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    GE              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    EQ              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    NE              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    AND             reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    OR              reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    SEMICOLON       reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    RPAREN          reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    LBRACE          reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    COMMA           reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    RBRACKET        reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)
    RBRACE          reduce using rule 49 (postfix_expr -> primary_expr postfix_chain .)


state 91

    (50) postfix_chain -> postfix . postfix_chain
    (50) postfix_chain -> . postfix postfix_chain
    (51) postfix_chain -> . empty
    (52) postfix -> . LPAREN args_opt RPAREN
    (53) postfix -> . DOT ID
    (54) postfix -> . LBRACKET expr RBRACKET
    (101) empty -> .

    LPAREN          shift and go to state 93
    DOT             shift and go to state 94
    LBRACKET        shift and go to state 95
    POWER           reduce using rule 101 (empty -> .)
    TIMES           reduce using rule 101 (empty -> .)
    DIVIDE          reduce using rule 101 (empty -> .)
    MOD             reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    LT              reduce using rule 101 (empty -> .)
    GT              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    LBRACE          reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)
    RBRACKET        reduce using rule 101 (empty -> .)
    RBRACE          reduce using rule 101 (empty -> .)

    postfix                        shift and go to state 91
    postfix_chain                  shift and go to state 131
    empty                          shift and go to state 92

state 92

    (51) postfix_chain -> empty .

    POWER           reduce using rule 51 (postfix_chain -> empty .)
    TIMES           reduce using rule 51 (postfix_chain -> empty .)
    DIVIDE          reduce using rule 51 (postfix_chain -> empty .)
    MOD             reduce using rule 51 (postfix_chain -> empty .)
    PLUS            reduce using rule 51 (postfix_chain -> empty .)
    MINUS           reduce using rule 51 (postfix_chain -> empty .)
    LT              reduce using rule 51 (postfix_chain -> empty .)
    GT              reduce using rule 51 (postfix_chain -> empty .)
    LE              reduce using rule 51 (postfix_chain -> empty .)
    GE              reduce using rule 51 (postfix_chain -> empty .)
    EQ              reduce using rule 51 (postfix_chain -> empty .)
    NE              reduce using rule 51 (postfix_chain -> empty .)
    AND             reduce using rule 51 (postfix_chain -> empty .)
    OR              reduce using rule 51 (postfix_chain -> empty .)
    SEMICOLON       reduce using rule 51 (postfix_chain -> empty .)
    RPAREN          reduce using rule 51 (postfix_chain -> empty .)
    LBRACE          reduce using rule 51 (postfix_chain -> empty .)
    COMMA           reduce using rule 51 (postfix_chain -> empty .)
    RBRACKET        reduce using rule 51 (postfix_chain -> empty .)
    RBRACE          reduce using rule 51 (postfix_chain -> empty .)


state 93

    (52) postfix -> LPAREN . args_opt RPAREN
    (86) args_opt -> . args
    (87) args_opt -> . empty
    (88) args -> . expr
    (89) args -> . args COMMA expr
    (101) empty -> .
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    RPAREN          reduce using rule 101 (empty -> .)
    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    args_opt                       shift and go to state 132
    args                           shift and go to state 133
    empty                          shift and go to state 134
    expr                           shift and go to state 135
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 94

    (53) postfix -> DOT . ID

    ID              shift and go to state 136


state 95

    (54) postfix -> LBRACKET . expr RBRACKET
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 137
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 96

    (16) import_stmt -> IMPORT STRING SEMICOLON .

    IMPORT          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    FN              reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    STRUCT          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    LET             reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    IF              reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    WHILE           reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    FOR             reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    RETURN          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    LBRACE          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    ID              reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    NOT             reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    MINUS           reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    LPAREN          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    INTEGER         reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    FLOAT           reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    STRING          reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    TRUE            reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    FALSE           reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    NULL            reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    LBRACKET        reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)
    $end            reduce using rule 16 (import_stmt -> IMPORT STRING SEMICOLON .)


state 97

    (17) function_decl -> FN ID LPAREN . parameters_opt RPAREN block
    (18) parameters_opt -> . parameters
    (19) parameters_opt -> . empty
    (20) parameters -> . ID
    (21) parameters -> . parameters COMMA ID
    (101) empty -> .

    ID              shift and go to state 138
    RPAREN          reduce using rule 101 (empty -> .)

    parameters_opt                 shift and go to state 139
    parameters                     shift and go to state 140
    empty                          shift and go to state 141

state 98

    (95) field_assign -> ID . COLON expr

    COLON           shift and go to state 142


state 99

    (90) struct_literal -> ID LBRACE field_assignments_opt . RBRACE

    RBRACE          shift and go to state 143


state 100

    (91) field_assignments_opt -> field_assignments .
    (94) field_assignments -> field_assignments . COMMA field_assign

    RBRACE          reduce using rule 91 (field_assignments_opt -> field_assignments .)
    COMMA           shift and go to state 144


state 101

    (92) field_assignments_opt -> empty .

    RBRACE          reduce using rule 92 (field_assignments_opt -> empty .)


state 102

    (93) field_assignments -> field_assign .

    COMMA           reduce using rule 93 (field_assignments -> field_assign .)
    RBRACE          reduce using rule 93 (field_assignments -> field_assign .)


state 103

    (46) primary_expr -> LPAREN expr RPAREN .

    LPAREN          reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    POWER           reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 46 (primary_expr -> LPAREN expr RPAREN .)


state 104

    (22) struct_decl -> STRUCT ID LBRACE . struct_fields RBRACE SEMICOLON
    (23) struct_fields -> . ID COMMA struct_fields
    (24) struct_fields -> . ID COMMA
    (25) struct_fields -> . empty
    (101) empty -> .

    ID              shift and go to state 145
    RBRACE          reduce using rule 101 (empty -> .)

    struct_fields                  shift and go to state 146
    empty                          shift and go to state 147

state 105

    (41) block -> LBRACE statement_list RBRACE .

    IMPORT          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    FN              reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    STRUCT          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    LET             reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    ID              reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    INTEGER         reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    STRING          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    NULL            reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    ELIF            reduce using rule 41 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 41 (block -> LBRACE statement_list RBRACE .)


state 106

    (42) statement_list -> statement_list statement .

    RBRACE          reduce using rule 42 (statement_list -> statement_list statement .)
    LET             reduce using rule 42 (statement_list -> statement_list statement .)
    IF              reduce using rule 42 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 42 (statement_list -> statement_list statement .)
    FOR             reduce using rule 42 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 42 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 42 (statement_list -> statement_list statement .)
    ID              reduce using rule 42 (statement_list -> statement_list statement .)
    NOT             reduce using rule 42 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 42 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 42 (statement_list -> statement_list statement .)
    INTEGER         reduce using rule 42 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 42 (statement_list -> statement_list statement .)
    STRING          reduce using rule 42 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 42 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 42 (statement_list -> statement_list statement .)
    NULL            reduce using rule 42 (statement_list -> statement_list statement .)
    LBRACKET        reduce using rule 42 (statement_list -> statement_list statement .)


state 107

    (26) variable_decl -> LET ID ASSIGN . expr SEMICOLON
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 148
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 108

    (27) assignment -> assign_target ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 149


state 109

    (29) assign_target -> assign_target DOT ID .

    ASSIGN          reduce using rule 29 (assign_target -> assign_target DOT ID .)
    DOT             reduce using rule 29 (assign_target -> assign_target DOT ID .)
    LBRACKET        reduce using rule 29 (assign_target -> assign_target DOT ID .)


state 110

    (30) assign_target -> assign_target LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 150


state 111

    (31) if_stmt -> IF expr block . elif_blocks else_block_opt
    (32) elif_blocks -> . elif_blocks ELIF expr block
    (33) elif_blocks -> . empty
    (101) empty -> .

    ELIF            reduce using rule 101 (empty -> .)
    ELSE            reduce using rule 101 (empty -> .)
    IMPORT          reduce using rule 101 (empty -> .)
    FN              reduce using rule 101 (empty -> .)
    STRUCT          reduce using rule 101 (empty -> .)
    LET             reduce using rule 101 (empty -> .)
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    LBRACE          reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    NOT             reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    LPAREN          reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    TRUE            reduce using rule 101 (empty -> .)
    FALSE           reduce using rule 101 (empty -> .)
    NULL            reduce using rule 101 (empty -> .)
    LBRACKET        reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)
    RBRACE          reduce using rule 101 (empty -> .)

    elif_blocks                    shift and go to state 151
    empty                          shift and go to state 152

state 112

    (36) while_stmt -> WHILE expr block .

    IMPORT          reduce using rule 36 (while_stmt -> WHILE expr block .)
    FN              reduce using rule 36 (while_stmt -> WHILE expr block .)
    STRUCT          reduce using rule 36 (while_stmt -> WHILE expr block .)
    LET             reduce using rule 36 (while_stmt -> WHILE expr block .)
    IF              reduce using rule 36 (while_stmt -> WHILE expr block .)
    WHILE           reduce using rule 36 (while_stmt -> WHILE expr block .)
    FOR             reduce using rule 36 (while_stmt -> WHILE expr block .)
    RETURN          reduce using rule 36 (while_stmt -> WHILE expr block .)
    LBRACE          reduce using rule 36 (while_stmt -> WHILE expr block .)
    ID              reduce using rule 36 (while_stmt -> WHILE expr block .)
    NOT             reduce using rule 36 (while_stmt -> WHILE expr block .)
    MINUS           reduce using rule 36 (while_stmt -> WHILE expr block .)
    LPAREN          reduce using rule 36 (while_stmt -> WHILE expr block .)
    INTEGER         reduce using rule 36 (while_stmt -> WHILE expr block .)
    FLOAT           reduce using rule 36 (while_stmt -> WHILE expr block .)
    STRING          reduce using rule 36 (while_stmt -> WHILE expr block .)
    TRUE            reduce using rule 36 (while_stmt -> WHILE expr block .)
    FALSE           reduce using rule 36 (while_stmt -> WHILE expr block .)
    NULL            reduce using rule 36 (while_stmt -> WHILE expr block .)
    LBRACKET        reduce using rule 36 (while_stmt -> WHILE expr block .)
    $end            reduce using rule 36 (while_stmt -> WHILE expr block .)
    RBRACE          reduce using rule 36 (while_stmt -> WHILE expr block .)


state 113

    (37) for_stmt -> FOR ID IN . expr block
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 153
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 114

    (38) return_stmt -> RETURN expr SEMICOLON .

    IMPORT          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    FN              reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    STRUCT          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    LET             reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    INTEGER         reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    LBRACKET        reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    $end            reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 38 (return_stmt -> RETURN expr SEMICOLON .)


state 115

    (96) array_literal -> LBRACKET expr_list_opt RBRACKET .

    LPAREN          reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    DOT             reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    LBRACKET        reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    POWER           reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    TIMES           reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    DIVIDE          reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    MOD             reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    PLUS            reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    MINUS           reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    LT              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    GT              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    LE              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    GE              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    EQ              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    NE              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    AND             reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    OR              reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    SEMICOLON       reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    RPAREN          reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    LBRACE          reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    COMMA           reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    RBRACKET        reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)
    RBRACE          reduce using rule 96 (array_literal -> LBRACKET expr_list_opt RBRACKET .)


state 116

    (100) expr_list -> expr_list COMMA . expr
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 154
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 117

    (78) logical_or_expr -> logical_or_expr OR logical_and_expr .
    (76) logical_and_expr -> logical_and_expr . AND equality_expr

    OR              reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    SEMICOLON       reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    RPAREN          reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    LBRACE          reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    COMMA           reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    RBRACKET        reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    RBRACE          reduce using rule 78 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    AND             shift and go to state 75


state 118

    (76) logical_and_expr -> logical_and_expr AND equality_expr .
    (73) equality_expr -> equality_expr . EQ relational_expr
    (74) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    OR              reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    SEMICOLON       reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    RPAREN          reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    LBRACE          reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    COMMA           reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    RBRACKET        reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    RBRACE          reduce using rule 76 (logical_and_expr -> logical_and_expr AND equality_expr .)
    EQ              shift and go to state 76
    NE              shift and go to state 77


state 119

    (73) equality_expr -> equality_expr EQ relational_expr .
    (68) relational_expr -> relational_expr . LT additive_expr
    (69) relational_expr -> relational_expr . GT additive_expr
    (70) relational_expr -> relational_expr . LE additive_expr
    (71) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    NE              reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    AND             reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    OR              reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    SEMICOLON       reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    RPAREN          reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    LBRACE          reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    COMMA           reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    RBRACKET        reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    RBRACE          reduce using rule 73 (equality_expr -> equality_expr EQ relational_expr .)
    LT              shift and go to state 78
    GT              shift and go to state 79
    LE              shift and go to state 80
    GE              shift and go to state 81


state 120

    (74) equality_expr -> equality_expr NE relational_expr .
    (68) relational_expr -> relational_expr . LT additive_expr
    (69) relational_expr -> relational_expr . GT additive_expr
    (70) relational_expr -> relational_expr . LE additive_expr
    (71) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    NE              reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    AND             reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    OR              reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    SEMICOLON       reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    RPAREN          reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    LBRACE          reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    COMMA           reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    RBRACKET        reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    RBRACE          reduce using rule 74 (equality_expr -> equality_expr NE relational_expr .)
    LT              shift and go to state 78
    GT              shift and go to state 79
    LE              shift and go to state 80
    GE              shift and go to state 81


state 121

    (68) relational_expr -> relational_expr LT additive_expr .
    (65) additive_expr -> additive_expr . PLUS multiplicative_expr
    (66) additive_expr -> additive_expr . MINUS multiplicative_expr

    LT              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    GE              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    NE              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    AND             reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    OR              reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    SEMICOLON       reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    RPAREN          reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    LBRACE          reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    COMMA           reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    RBRACKET        reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    RBRACE          reduce using rule 68 (relational_expr -> relational_expr LT additive_expr .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 122

    (69) relational_expr -> relational_expr GT additive_expr .
    (65) additive_expr -> additive_expr . PLUS multiplicative_expr
    (66) additive_expr -> additive_expr . MINUS multiplicative_expr

    LT              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    GE              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    NE              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    AND             reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    OR              reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    SEMICOLON       reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    RPAREN          reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    LBRACE          reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    COMMA           reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    RBRACKET        reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    RBRACE          reduce using rule 69 (relational_expr -> relational_expr GT additive_expr .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 123

    (70) relational_expr -> relational_expr LE additive_expr .
    (65) additive_expr -> additive_expr . PLUS multiplicative_expr
    (66) additive_expr -> additive_expr . MINUS multiplicative_expr

    LT              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    GE              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    NE              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    AND             reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    OR              reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    SEMICOLON       reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    RPAREN          reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    LBRACE          reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    COMMA           reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    RBRACKET        reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    RBRACE          reduce using rule 70 (relational_expr -> relational_expr LE additive_expr .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 124

    (71) relational_expr -> relational_expr GE additive_expr .
    (65) additive_expr -> additive_expr . PLUS multiplicative_expr
    (66) additive_expr -> additive_expr . MINUS multiplicative_expr

    LT              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    GE              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    NE              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    AND             reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    OR              reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    SEMICOLON       reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    RPAREN          reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    LBRACE          reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    COMMA           reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    RBRACKET        reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    RBRACE          reduce using rule 71 (relational_expr -> relational_expr GE additive_expr .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 125

    (65) additive_expr -> additive_expr PLUS multiplicative_expr .
    (61) multiplicative_expr -> multiplicative_expr . TIMES exponential_expr
    (62) multiplicative_expr -> multiplicative_expr . DIVIDE exponential_expr
    (63) multiplicative_expr -> multiplicative_expr . MOD exponential_expr

    PLUS            reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    MINUS           reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    LT              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    GT              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    LE              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    GE              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    EQ              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    NE              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    AND             reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    OR              reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    SEMICOLON       reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    RPAREN          reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    LBRACE          reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    COMMA           reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    RBRACKET        reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    RBRACE          reduce using rule 65 (additive_expr -> additive_expr PLUS multiplicative_expr .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 126

    (66) additive_expr -> additive_expr MINUS multiplicative_expr .
    (61) multiplicative_expr -> multiplicative_expr . TIMES exponential_expr
    (62) multiplicative_expr -> multiplicative_expr . DIVIDE exponential_expr
    (63) multiplicative_expr -> multiplicative_expr . MOD exponential_expr

    PLUS            reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    MINUS           reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    LT              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    GT              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    LE              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    GE              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    EQ              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    NE              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    AND             reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    OR              reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    SEMICOLON       reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    RPAREN          reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    LBRACE          reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    COMMA           reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    RBRACKET        reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    RBRACE          reduce using rule 66 (additive_expr -> additive_expr MINUS multiplicative_expr .)
    TIMES           shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 127

    (61) multiplicative_expr -> multiplicative_expr TIMES exponential_expr .

    TIMES           reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    DIVIDE          reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    MOD             reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    PLUS            reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    MINUS           reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    LT              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    GT              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    LE              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    GE              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    EQ              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    NE              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    AND             reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    OR              reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    SEMICOLON       reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    RPAREN          reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    LBRACE          reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    COMMA           reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    RBRACKET        reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)
    RBRACE          reduce using rule 61 (multiplicative_expr -> multiplicative_expr TIMES exponential_expr .)


state 128

    (62) multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .

    TIMES           reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    DIVIDE          reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    MOD             reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    PLUS            reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    MINUS           reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    LT              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    GT              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    LE              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    GE              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    EQ              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    NE              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    AND             reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    OR              reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    SEMICOLON       reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    RPAREN          reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    LBRACE          reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    COMMA           reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    RBRACKET        reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)
    RBRACE          reduce using rule 62 (multiplicative_expr -> multiplicative_expr DIVIDE exponential_expr .)


state 129

    (63) multiplicative_expr -> multiplicative_expr MOD exponential_expr .

    TIMES           reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    DIVIDE          reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    MOD             reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    PLUS            reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    MINUS           reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    LT              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    GT              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    LE              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    GE              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    EQ              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    NE              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    AND             reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    OR              reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    SEMICOLON       reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    RPAREN          reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    LBRACE          reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    COMMA           reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    RBRACKET        reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)
    RBRACE          reduce using rule 63 (multiplicative_expr -> multiplicative_expr MOD exponential_expr .)


state 130

    (59) exponential_expr -> unary_expr POWER exponential_expr .

    TIMES           reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    DIVIDE          reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    MOD             reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    PLUS            reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    MINUS           reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    LT              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    GT              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    LE              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    GE              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    EQ              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    NE              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    AND             reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    OR              reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    SEMICOLON       reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    RPAREN          reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    LBRACE          reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    COMMA           reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    RBRACKET        reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)
    RBRACE          reduce using rule 59 (exponential_expr -> unary_expr POWER exponential_expr .)


state 131

    (50) postfix_chain -> postfix postfix_chain .

    POWER           reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    TIMES           reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    DIVIDE          reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    MOD             reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    PLUS            reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    MINUS           reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    LT              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    GT              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    LE              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    GE              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    EQ              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    NE              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    AND             reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    OR              reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    SEMICOLON       reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    RPAREN          reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    LBRACE          reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    COMMA           reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    RBRACKET        reduce using rule 50 (postfix_chain -> postfix postfix_chain .)
    RBRACE          reduce using rule 50 (postfix_chain -> postfix postfix_chain .)


state 132

    (52) postfix -> LPAREN args_opt . RPAREN

    RPAREN          shift and go to state 155


state 133

    (86) args_opt -> args .
    (89) args -> args . COMMA expr

    RPAREN          reduce using rule 86 (args_opt -> args .)
    COMMA           shift and go to state 156


state 134

    (87) args_opt -> empty .

    RPAREN          reduce using rule 87 (args_opt -> empty .)


state 135

    (88) args -> expr .

    COMMA           reduce using rule 88 (args -> expr .)
    RPAREN          reduce using rule 88 (args -> expr .)


state 136

    (53) postfix -> DOT ID .

    LPAREN          reduce using rule 53 (postfix -> DOT ID .)
    DOT             reduce using rule 53 (postfix -> DOT ID .)
    LBRACKET        reduce using rule 53 (postfix -> DOT ID .)
    POWER           reduce using rule 53 (postfix -> DOT ID .)
    TIMES           reduce using rule 53 (postfix -> DOT ID .)
    DIVIDE          reduce using rule 53 (postfix -> DOT ID .)
    MOD             reduce using rule 53 (postfix -> DOT ID .)
    PLUS            reduce using rule 53 (postfix -> DOT ID .)
    MINUS           reduce using rule 53 (postfix -> DOT ID .)
    LT              reduce using rule 53 (postfix -> DOT ID .)
    GT              reduce using rule 53 (postfix -> DOT ID .)
    LE              reduce using rule 53 (postfix -> DOT ID .)
    GE              reduce using rule 53 (postfix -> DOT ID .)
    EQ              reduce using rule 53 (postfix -> DOT ID .)
    NE              reduce using rule 53 (postfix -> DOT ID .)
    AND             reduce using rule 53 (postfix -> DOT ID .)
    OR              reduce using rule 53 (postfix -> DOT ID .)
    SEMICOLON       reduce using rule 53 (postfix -> DOT ID .)
    RPAREN          reduce using rule 53 (postfix -> DOT ID .)
    LBRACE          reduce using rule 53 (postfix -> DOT ID .)
    COMMA           reduce using rule 53 (postfix -> DOT ID .)
    RBRACKET        reduce using rule 53 (postfix -> DOT ID .)
    RBRACE          reduce using rule 53 (postfix -> DOT ID .)


state 137

    (54) postfix -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 157


state 138

    (20) parameters -> ID .

    COMMA           reduce using rule 20 (parameters -> ID .)
    RPAREN          reduce using rule 20 (parameters -> ID .)


state 139

    (17) function_decl -> FN ID LPAREN parameters_opt . RPAREN block

    RPAREN          shift and go to state 158


state 140

    (18) parameters_opt -> parameters .
    (21) parameters -> parameters . COMMA ID

    RPAREN          reduce using rule 18 (parameters_opt -> parameters .)
    COMMA           shift and go to state 159


state 141

    (19) parameters_opt -> empty .

    RPAREN          reduce using rule 19 (parameters_opt -> empty .)


state 142

    (95) field_assign -> ID COLON . expr
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 160
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 143

    (90) struct_literal -> ID LBRACE field_assignments_opt RBRACE .

    LPAREN          reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    DOT             reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    LBRACKET        reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    POWER           reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    TIMES           reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    DIVIDE          reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    MOD             reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    PLUS            reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    MINUS           reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    LT              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    GT              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    LE              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    GE              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    EQ              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    NE              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    AND             reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    OR              reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    SEMICOLON       reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    RPAREN          reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    LBRACE          reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    COMMA           reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    RBRACKET        reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)
    RBRACE          reduce using rule 90 (struct_literal -> ID LBRACE field_assignments_opt RBRACE .)


state 144

    (94) field_assignments -> field_assignments COMMA . field_assign
    (95) field_assign -> . ID COLON expr

    ID              shift and go to state 98

    field_assign                   shift and go to state 161

state 145

    (23) struct_fields -> ID . COMMA struct_fields
    (24) struct_fields -> ID . COMMA

    COMMA           shift and go to state 162


state 146

    (22) struct_decl -> STRUCT ID LBRACE struct_fields . RBRACE SEMICOLON

    RBRACE          shift and go to state 163


state 147

    (25) struct_fields -> empty .

    RBRACE          reduce using rule 25 (struct_fields -> empty .)


state 148

    (26) variable_decl -> LET ID ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 164


state 149

    (27) assignment -> assign_target ASSIGN expr SEMICOLON .

    IMPORT          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    FN              reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    STRUCT          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    LET             reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    IF              reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    ID              reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    INTEGER         reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    TRUE            reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    FALSE           reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    NULL            reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    LBRACKET        reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    $end            reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 27 (assignment -> assign_target ASSIGN expr SEMICOLON .)


state 150

    (30) assign_target -> assign_target LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 30 (assign_target -> assign_target LBRACKET expr RBRACKET .)
    DOT             reduce using rule 30 (assign_target -> assign_target LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 30 (assign_target -> assign_target LBRACKET expr RBRACKET .)


state 151

    (31) if_stmt -> IF expr block elif_blocks . else_block_opt
    (32) elif_blocks -> elif_blocks . ELIF expr block
    (34) else_block_opt -> . ELSE block
    (35) else_block_opt -> . empty
    (101) empty -> .

    ELIF            shift and go to state 166
    ELSE            shift and go to state 167
    IMPORT          reduce using rule 101 (empty -> .)
    FN              reduce using rule 101 (empty -> .)
    STRUCT          reduce using rule 101 (empty -> .)
    LET             reduce using rule 101 (empty -> .)
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    LBRACE          reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    NOT             reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    LPAREN          reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    TRUE            reduce using rule 101 (empty -> .)
    FALSE           reduce using rule 101 (empty -> .)
    NULL            reduce using rule 101 (empty -> .)
    LBRACKET        reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)
    RBRACE          reduce using rule 101 (empty -> .)

    else_block_opt                 shift and go to state 165
    empty                          shift and go to state 168

state 152

    (33) elif_blocks -> empty .

    ELIF            reduce using rule 33 (elif_blocks -> empty .)
    ELSE            reduce using rule 33 (elif_blocks -> empty .)
    IMPORT          reduce using rule 33 (elif_blocks -> empty .)
    FN              reduce using rule 33 (elif_blocks -> empty .)
    STRUCT          reduce using rule 33 (elif_blocks -> empty .)
    LET             reduce using rule 33 (elif_blocks -> empty .)
    IF              reduce using rule 33 (elif_blocks -> empty .)
    WHILE           reduce using rule 33 (elif_blocks -> empty .)
    FOR             reduce using rule 33 (elif_blocks -> empty .)
    RETURN          reduce using rule 33 (elif_blocks -> empty .)
    LBRACE          reduce using rule 33 (elif_blocks -> empty .)
    ID              reduce using rule 33 (elif_blocks -> empty .)
    NOT             reduce using rule 33 (elif_blocks -> empty .)
    MINUS           reduce using rule 33 (elif_blocks -> empty .)
    LPAREN          reduce using rule 33 (elif_blocks -> empty .)
    INTEGER         reduce using rule 33 (elif_blocks -> empty .)
    FLOAT           reduce using rule 33 (elif_blocks -> empty .)
    STRING          reduce using rule 33 (elif_blocks -> empty .)
    TRUE            reduce using rule 33 (elif_blocks -> empty .)
    FALSE           reduce using rule 33 (elif_blocks -> empty .)
    NULL            reduce using rule 33 (elif_blocks -> empty .)
    LBRACKET        reduce using rule 33 (elif_blocks -> empty .)
    $end            reduce using rule 33 (elif_blocks -> empty .)
    RBRACE          reduce using rule 33 (elif_blocks -> empty .)


state 153

    (37) for_stmt -> FOR ID IN expr . block
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 169

state 154

    (100) expr_list -> expr_list COMMA expr .

    COMMA           reduce using rule 100 (expr_list -> expr_list COMMA expr .)
    RBRACKET        reduce using rule 100 (expr_list -> expr_list COMMA expr .)


state 155

    (52) postfix -> LPAREN args_opt RPAREN .

    LPAREN          reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    DOT             reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    LBRACKET        reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    POWER           reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    TIMES           reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    DIVIDE          reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    MOD             reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    PLUS            reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    MINUS           reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    LT              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    GT              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    LE              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    GE              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    EQ              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    NE              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    AND             reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    OR              reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    SEMICOLON       reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    RPAREN          reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    LBRACE          reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    COMMA           reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    RBRACKET        reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)
    RBRACE          reduce using rule 52 (postfix -> LPAREN args_opt RPAREN .)


state 156

    (89) args -> args COMMA . expr
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 170
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 157

    (54) postfix -> LBRACKET expr RBRACKET .

    LPAREN          reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    DOT             reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    POWER           reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    LE              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    GE              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    NE              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 54 (postfix -> LBRACKET expr RBRACKET .)


state 158

    (17) function_decl -> FN ID LPAREN parameters_opt RPAREN . block
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 171

state 159

    (21) parameters -> parameters COMMA . ID

    ID              shift and go to state 172


state 160

    (95) field_assign -> ID COLON expr .

    COMMA           reduce using rule 95 (field_assign -> ID COLON expr .)
    RBRACE          reduce using rule 95 (field_assign -> ID COLON expr .)


state 161

    (94) field_assignments -> field_assignments COMMA field_assign .

    COMMA           reduce using rule 94 (field_assignments -> field_assignments COMMA field_assign .)
    RBRACE          reduce using rule 94 (field_assignments -> field_assignments COMMA field_assign .)


state 162

    (23) struct_fields -> ID COMMA . struct_fields
    (24) struct_fields -> ID COMMA .
    (23) struct_fields -> . ID COMMA struct_fields
    (24) struct_fields -> . ID COMMA
    (25) struct_fields -> . empty
    (101) empty -> .

  ! reduce/reduce conflict for RBRACE resolved using rule 24 (struct_fields -> ID COMMA .)
    RBRACE          reduce using rule 24 (struct_fields -> ID COMMA .)
    ID              shift and go to state 145

  ! RBRACE          [ reduce using rule 101 (empty -> .) ]

    struct_fields                  shift and go to state 173
    empty                          shift and go to state 147

state 163

    (22) struct_decl -> STRUCT ID LBRACE struct_fields RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 174


state 164

    (26) variable_decl -> LET ID ASSIGN expr SEMICOLON .

    IMPORT          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    FN              reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    STRUCT          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    LET             reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    INTEGER         reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    TRUE            reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    FALSE           reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    NULL            reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    LBRACKET        reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 26 (variable_decl -> LET ID ASSIGN expr SEMICOLON .)


state 165

    (31) if_stmt -> IF expr block elif_blocks else_block_opt .

    IMPORT          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    FN              reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    STRUCT          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    LET             reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    IF              reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    WHILE           reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    FOR             reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    RETURN          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    LBRACE          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    ID              reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    NOT             reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    MINUS           reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    LPAREN          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    INTEGER         reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    FLOAT           reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    STRING          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    TRUE            reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    FALSE           reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    NULL            reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    LBRACKET        reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    $end            reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)
    RBRACE          reduce using rule 31 (if_stmt -> IF expr block elif_blocks else_block_opt .)


state 166

    (32) elif_blocks -> elif_blocks ELIF . expr block
    (79) expr -> . logical_or_expr
    (77) logical_or_expr -> . logical_and_expr
    (78) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (75) logical_and_expr -> . equality_expr
    (76) logical_and_expr -> . logical_and_expr AND equality_expr
    (72) equality_expr -> . relational_expr
    (73) equality_expr -> . equality_expr EQ relational_expr
    (74) equality_expr -> . equality_expr NE relational_expr
    (67) relational_expr -> . additive_expr
    (68) relational_expr -> . relational_expr LT additive_expr
    (69) relational_expr -> . relational_expr GT additive_expr
    (70) relational_expr -> . relational_expr LE additive_expr
    (71) relational_expr -> . relational_expr GE additive_expr
    (64) additive_expr -> . multiplicative_expr
    (65) additive_expr -> . additive_expr PLUS multiplicative_expr
    (66) additive_expr -> . additive_expr MINUS multiplicative_expr
    (60) multiplicative_expr -> . exponential_expr
    (61) multiplicative_expr -> . multiplicative_expr TIMES exponential_expr
    (62) multiplicative_expr -> . multiplicative_expr DIVIDE exponential_expr
    (63) multiplicative_expr -> . multiplicative_expr MOD exponential_expr
    (58) exponential_expr -> . unary_expr
    (59) exponential_expr -> . unary_expr POWER exponential_expr
    (55) unary_expr -> . NOT unary_expr
    (56) unary_expr -> . MINUS unary_expr
    (57) unary_expr -> . postfix_expr
    (49) postfix_expr -> . primary_expr postfix_chain
    (44) primary_expr -> . ID
    (45) primary_expr -> . literal
    (46) primary_expr -> . LPAREN expr RPAREN
    (47) primary_expr -> . struct_literal
    (48) primary_expr -> . array_literal
    (80) literal -> . INTEGER
    (81) literal -> . FLOAT
    (82) literal -> . STRING
    (83) literal -> . TRUE
    (84) literal -> . FALSE
    (85) literal -> . NULL
    (90) struct_literal -> . ID LBRACE field_assignments_opt RBRACE
    (96) array_literal -> . LBRACKET expr_list_opt RBRACKET

    NOT             shift and go to state 40
    MINUS           shift and go to state 37
    ID              shift and go to state 56
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47
    STRING          shift and go to state 9
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    LBRACKET        shift and go to state 30

    expr                           shift and go to state 175
    logical_or_expr                shift and go to state 31
    logical_and_expr               shift and go to state 32
    equality_expr                  shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 35
    multiplicative_expr            shift and go to state 36
    exponential_expr               shift and go to state 38
    unary_expr                     shift and go to state 39
    postfix_expr                   shift and go to state 41
    primary_expr                   shift and go to state 42
    literal                        shift and go to state 43
    struct_literal                 shift and go to state 44
    array_literal                  shift and go to state 45

state 167

    (34) else_block_opt -> ELSE . block
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 176

state 168

    (35) else_block_opt -> empty .

    IMPORT          reduce using rule 35 (else_block_opt -> empty .)
    FN              reduce using rule 35 (else_block_opt -> empty .)
    STRUCT          reduce using rule 35 (else_block_opt -> empty .)
    LET             reduce using rule 35 (else_block_opt -> empty .)
    IF              reduce using rule 35 (else_block_opt -> empty .)
    WHILE           reduce using rule 35 (else_block_opt -> empty .)
    FOR             reduce using rule 35 (else_block_opt -> empty .)
    RETURN          reduce using rule 35 (else_block_opt -> empty .)
    LBRACE          reduce using rule 35 (else_block_opt -> empty .)
    ID              reduce using rule 35 (else_block_opt -> empty .)
    NOT             reduce using rule 35 (else_block_opt -> empty .)
    MINUS           reduce using rule 35 (else_block_opt -> empty .)
    LPAREN          reduce using rule 35 (else_block_opt -> empty .)
    INTEGER         reduce using rule 35 (else_block_opt -> empty .)
    FLOAT           reduce using rule 35 (else_block_opt -> empty .)
    STRING          reduce using rule 35 (else_block_opt -> empty .)
    TRUE            reduce using rule 35 (else_block_opt -> empty .)
    FALSE           reduce using rule 35 (else_block_opt -> empty .)
    NULL            reduce using rule 35 (else_block_opt -> empty .)
    LBRACKET        reduce using rule 35 (else_block_opt -> empty .)
    $end            reduce using rule 35 (else_block_opt -> empty .)
    RBRACE          reduce using rule 35 (else_block_opt -> empty .)


state 169

    (37) for_stmt -> FOR ID IN expr block .

    IMPORT          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    FN              reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    STRUCT          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    LET             reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    IF              reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    WHILE           reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    FOR             reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    RETURN          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    LBRACE          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    ID              reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    NOT             reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    MINUS           reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    LPAREN          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    INTEGER         reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    FLOAT           reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    STRING          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    TRUE            reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    FALSE           reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    NULL            reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    LBRACKET        reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    $end            reduce using rule 37 (for_stmt -> FOR ID IN expr block .)
    RBRACE          reduce using rule 37 (for_stmt -> FOR ID IN expr block .)


state 170

    (89) args -> args COMMA expr .

    COMMA           reduce using rule 89 (args -> args COMMA expr .)
    RPAREN          reduce using rule 89 (args -> args COMMA expr .)


state 171

    (17) function_decl -> FN ID LPAREN parameters_opt RPAREN block .

    IMPORT          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    FN              reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    STRUCT          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    LET             reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    IF              reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    WHILE           reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    FOR             reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    RETURN          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    LBRACE          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    ID              reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    NOT             reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    MINUS           reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    LPAREN          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    INTEGER         reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    FLOAT           reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    STRING          reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    TRUE            reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    FALSE           reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    NULL            reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    LBRACKET        reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)
    $end            reduce using rule 17 (function_decl -> FN ID LPAREN parameters_opt RPAREN block .)


state 172

    (21) parameters -> parameters COMMA ID .

    COMMA           reduce using rule 21 (parameters -> parameters COMMA ID .)
    RPAREN          reduce using rule 21 (parameters -> parameters COMMA ID .)


state 173

    (23) struct_fields -> ID COMMA struct_fields .

    RBRACE          reduce using rule 23 (struct_fields -> ID COMMA struct_fields .)


state 174

    (22) struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .

    IMPORT          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    FN              reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    STRUCT          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    LET             reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    IF              reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    FOR             reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    RETURN          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    LBRACE          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    ID              reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    NOT             reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    MINUS           reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    LPAREN          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    INTEGER         reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    FLOAT           reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    STRING          reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    TRUE            reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    FALSE           reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    NULL            reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    LBRACKET        reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)
    $end            reduce using rule 22 (struct_decl -> STRUCT ID LBRACE struct_fields RBRACE SEMICOLON .)


state 175

    (32) elif_blocks -> elif_blocks ELIF expr . block
    (41) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    block                          shift and go to state 177

state 176

    (34) else_block_opt -> ELSE block .

    IMPORT          reduce using rule 34 (else_block_opt -> ELSE block .)
    FN              reduce using rule 34 (else_block_opt -> ELSE block .)
    STRUCT          reduce using rule 34 (else_block_opt -> ELSE block .)
    LET             reduce using rule 34 (else_block_opt -> ELSE block .)
    IF              reduce using rule 34 (else_block_opt -> ELSE block .)
    WHILE           reduce using rule 34 (else_block_opt -> ELSE block .)
    FOR             reduce using rule 34 (else_block_opt -> ELSE block .)
    RETURN          reduce using rule 34 (else_block_opt -> ELSE block .)
    LBRACE          reduce using rule 34 (else_block_opt -> ELSE block .)
    ID              reduce using rule 34 (else_block_opt -> ELSE block .)
    NOT             reduce using rule 34 (else_block_opt -> ELSE block .)
    MINUS           reduce using rule 34 (else_block_opt -> ELSE block .)
    LPAREN          reduce using rule 34 (else_block_opt -> ELSE block .)
    INTEGER         reduce using rule 34 (else_block_opt -> ELSE block .)
    FLOAT           reduce using rule 34 (else_block_opt -> ELSE block .)
    STRING          reduce using rule 34 (else_block_opt -> ELSE block .)
    TRUE            reduce using rule 34 (else_block_opt -> ELSE block .)
    FALSE           reduce using rule 34 (else_block_opt -> ELSE block .)
    NULL            reduce using rule 34 (else_block_opt -> ELSE block .)
    LBRACKET        reduce using rule 34 (else_block_opt -> ELSE block .)
    $end            reduce using rule 34 (else_block_opt -> ELSE block .)
    RBRACE          reduce using rule 34 (else_block_opt -> ELSE block .)


state 177

    (32) elif_blocks -> elif_blocks ELIF expr block .

    ELIF            reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    ELSE            reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    IMPORT          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    FN              reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    STRUCT          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    LET             reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    IF              reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    WHILE           reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    FOR             reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    RETURN          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    LBRACE          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    ID              reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    NOT             reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    MINUS           reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    LPAREN          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    INTEGER         reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    FLOAT           reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    STRING          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    TRUE            reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    FALSE           reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    NULL            reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    LBRACKET        reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    $end            reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)
    RBRACE          reduce using rule 32 (elif_blocks -> elif_blocks ELIF expr block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 56 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (assign_target -> ID)
WARNING: rejected rule (primary_expr -> ID) in state 11
WARNING: reduce/reduce conflict in state 162 resolved using rule (struct_fields -> ID COMMA)
WARNING: rejected rule (empty -> <empty>) in state 162
